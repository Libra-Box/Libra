// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: box.proto

package pb

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// response code
type Code int32

const (
	Code_Success           Code = 0
	Code_Failure           Code = 1
	Code_InvalidSignature  Code = 2
	Code_TokenError        Code = 3
	Code_TokenExpired      Code = 4
	Code_DeviceActivated   Code = 5
	Code_DbError           Code = 6
	Code_IoError           Code = 7
	Code_UserPassError     Code = 8
	Code_RequestParamError Code = 9
	Code_NoEnoughSpace     Code = 10
	Code_NetworkError      Code = 11
	Code_RequestTimeout    Code = 12
	Code_UserDisabled      Code = 13
	Code_UserCountIsOver   Code = 14
	Code_FileNameExist     Code = 15
	Code_UserNameNotExist  Code = 16
	Code_SystemFile        Code = 17
	Code_BackingUp         Code = 18
	Code_Md5IsExist        Code = 19
	Code_SizeInsufficient  Code = 20
)

var Code_name = map[int32]string{
	0:  "Success",
	1:  "Failure",
	2:  "InvalidSignature",
	3:  "TokenError",
	4:  "TokenExpired",
	5:  "DeviceActivated",
	6:  "DbError",
	7:  "IoError",
	8:  "UserPassError",
	9:  "RequestParamError",
	10: "NoEnoughSpace",
	11: "NetworkError",
	12: "RequestTimeout",
	13: "UserDisabled",
	14: "UserCountIsOver",
	15: "FileNameExist",
	16: "UserNameNotExist",
	17: "SystemFile",
	18: "BackingUp",
	19: "Md5IsExist",
	20: "SizeInsufficient",
}

var Code_value = map[string]int32{
	"Success":           0,
	"Failure":           1,
	"InvalidSignature":  2,
	"TokenError":        3,
	"TokenExpired":      4,
	"DeviceActivated":   5,
	"DbError":           6,
	"IoError":           7,
	"UserPassError":     8,
	"RequestParamError": 9,
	"NoEnoughSpace":     10,
	"NetworkError":      11,
	"RequestTimeout":    12,
	"UserDisabled":      13,
	"UserCountIsOver":   14,
	"FileNameExist":     15,
	"UserNameNotExist":  16,
	"SystemFile":        17,
	"BackingUp":         18,
	"Md5IsExist":        19,
	"SizeInsufficient":  20,
}

func (x Code) String() string {
	return proto.EnumName(Code_name, int32(x))
}

func (Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{0}
}

// protoc --gofast_out=. --proto_path=. *.proto
// protoc --js_out=import_style=commonjs,binary:. *.proto
// relay 代理传输
// "/box/relay/1.0.0"
// "http://122.9.61.5:9988/v1/box/relay/1.0.0"
type RelayReq struct {
	ProtocolId           string   `protobuf:"bytes,1,opt,name=ProtocolId,proto3" json:"ProtocolId"`
	BodyBuffer           []byte   `protobuf:"bytes,2,opt,name=BodyBuffer,proto3" json:"BodyBuffer"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RelayReq) Reset()         { *m = RelayReq{} }
func (m *RelayReq) String() string { return proto.CompactTextString(m) }
func (*RelayReq) ProtoMessage()    {}
func (*RelayReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{0}
}
func (m *RelayReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelayReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelayReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RelayReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelayReq.Merge(m, src)
}
func (m *RelayReq) XXX_Size() int {
	return m.Size()
}
func (m *RelayReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RelayReq.DiscardUnknown(m)
}

var xxx_messageInfo_RelayReq proto.InternalMessageInfo

func (m *RelayReq) GetProtocolId() string {
	if m != nil {
		return m.ProtocolId
	}
	return ""
}

func (m *RelayReq) GetBodyBuffer() []byte {
	if m != nil {
		return m.BodyBuffer
	}
	return nil
}

type RelayResp struct {
	ProtocolId           string   `protobuf:"bytes,1,opt,name=ProtocolId,proto3" json:"ProtocolId"`
	BodyBuffer           []byte   `protobuf:"bytes,2,opt,name=BodyBuffer,proto3" json:"BodyBuffer"`
	Code                 uint32   `protobuf:"varint,3,opt,name=code,proto3" json:"code"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RelayResp) Reset()         { *m = RelayResp{} }
func (m *RelayResp) String() string { return proto.CompactTextString(m) }
func (*RelayResp) ProtoMessage()    {}
func (*RelayResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{1}
}
func (m *RelayResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelayResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelayResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RelayResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelayResp.Merge(m, src)
}
func (m *RelayResp) XXX_Size() int {
	return m.Size()
}
func (m *RelayResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RelayResp.DiscardUnknown(m)
}

var xxx_messageInfo_RelayResp proto.InternalMessageInfo

func (m *RelayResp) GetProtocolId() string {
	if m != nil {
		return m.ProtocolId
	}
	return ""
}

func (m *RelayResp) GetBodyBuffer() []byte {
	if m != nil {
		return m.BodyBuffer
	}
	return nil
}

func (m *RelayResp) GetCode() uint32 {
	if m != nil {
		return m.Code
	}
	return 0
}

type CommonResp struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code     `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string   `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommonResp) Reset()         { *m = CommonResp{} }
func (m *CommonResp) String() string { return proto.CompactTextString(m) }
func (*CommonResp) ProtoMessage()    {}
func (*CommonResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{2}
}
func (m *CommonResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonResp.Merge(m, src)
}
func (m *CommonResp) XXX_Size() int {
	return m.Size()
}
func (m *CommonResp) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonResp.DiscardUnknown(m)
}

var xxx_messageInfo_CommonResp proto.InternalMessageInfo

func (m *CommonResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *CommonResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *CommonResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// "/box/ping/1.0.0"
type PingReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PingReq) Reset()         { *m = PingReq{} }
func (m *PingReq) String() string { return proto.CompactTextString(m) }
func (*PingReq) ProtoMessage()    {}
func (*PingReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{3}
}
func (m *PingReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PingReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PingReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PingReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PingReq.Merge(m, src)
}
func (m *PingReq) XXX_Size() int {
	return m.Size()
}
func (m *PingReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PingReq.DiscardUnknown(m)
}

var xxx_messageInfo_PingReq proto.InternalMessageInfo

func (m *PingReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

type PingResp struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PingResp) Reset()         { *m = PingResp{} }
func (m *PingResp) String() string { return proto.CompactTextString(m) }
func (*PingResp) ProtoMessage()    {}
func (*PingResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{4}
}
func (m *PingResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PingResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PingResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PingResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PingResp.Merge(m, src)
}
func (m *PingResp) XXX_Size() int {
	return m.Size()
}
func (m *PingResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PingResp.DiscardUnknown(m)
}

var xxx_messageInfo_PingResp proto.InternalMessageInfo

func (m *PingResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

////////////////////////////////////////////////////////////////////////
// 获取设备ipfs网络地址
// "/box/peer_address/1.0.0"
// Http Post Json : http://122.9.61.5:16516/v1/peer_addr
type PeerAddressReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	PeerId               string   `protobuf:"bytes,2,opt,name=peerId,proto3" json:"peerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PeerAddressReq) Reset()         { *m = PeerAddressReq{} }
func (m *PeerAddressReq) String() string { return proto.CompactTextString(m) }
func (*PeerAddressReq) ProtoMessage()    {}
func (*PeerAddressReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{5}
}
func (m *PeerAddressReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerAddressReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerAddressReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerAddressReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerAddressReq.Merge(m, src)
}
func (m *PeerAddressReq) XXX_Size() int {
	return m.Size()
}
func (m *PeerAddressReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerAddressReq.DiscardUnknown(m)
}

var xxx_messageInfo_PeerAddressReq proto.InternalMessageInfo

func (m *PeerAddressReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *PeerAddressReq) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

type PeerAddressResp struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code     `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	PeerAddress          []string `protobuf:"bytes,3,rep,name=peerAddress,proto3" json:"peerAddress"`
	Msg                  string   `protobuf:"bytes,4,opt,name=msg,proto3" json:"msg"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PeerAddressResp) Reset()         { *m = PeerAddressResp{} }
func (m *PeerAddressResp) String() string { return proto.CompactTextString(m) }
func (*PeerAddressResp) ProtoMessage()    {}
func (*PeerAddressResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{6}
}
func (m *PeerAddressResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerAddressResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerAddressResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerAddressResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerAddressResp.Merge(m, src)
}
func (m *PeerAddressResp) XXX_Size() int {
	return m.Size()
}
func (m *PeerAddressResp) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerAddressResp.DiscardUnknown(m)
}

var xxx_messageInfo_PeerAddressResp proto.InternalMessageInfo

func (m *PeerAddressResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *PeerAddressResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *PeerAddressResp) GetPeerAddress() []string {
	if m != nil {
		return m.PeerAddress
	}
	return nil
}

func (m *PeerAddressResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

////////////////////////////////////////////////////////////////////////
// 用户数据
type User struct {
	Id                   uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Role                 int32    `protobuf:"varint,3,opt,name=role,proto3" json:"role"`
	AllocatedSpace       uint64   `protobuf:"varint,4,opt,name=allocatedSpace,proto3" json:"allocatedSpace"`
	UsedSpace            uint64   `protobuf:"varint,5,opt,name=usedSpace,proto3" json:"usedSpace"`
	Status               int32    `protobuf:"varint,6,opt,name=status,proto3" json:"status"`
	DeviceName           string   `protobuf:"bytes,7,opt,name=deviceName,proto3" json:"deviceName"`
	CreatedAt            int64    `protobuf:"varint,8,opt,name=createdAt,proto3" json:"createdAt"`
	Password             string   `protobuf:"bytes,9,opt,name=password,proto3" json:"password"`
	SyncFil              int32    `protobuf:"varint,10,opt,name=syncFil,proto3" json:"syncFil"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}
func (*User) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{7}
}
func (m *User) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *User) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_User.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *User) XXX_Merge(src proto.Message) {
	xxx_messageInfo_User.Merge(m, src)
}
func (m *User) XXX_Size() int {
	return m.Size()
}
func (m *User) XXX_DiscardUnknown() {
	xxx_messageInfo_User.DiscardUnknown(m)
}

var xxx_messageInfo_User proto.InternalMessageInfo

func (m *User) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *User) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *User) GetRole() int32 {
	if m != nil {
		return m.Role
	}
	return 0
}

func (m *User) GetAllocatedSpace() uint64 {
	if m != nil {
		return m.AllocatedSpace
	}
	return 0
}

func (m *User) GetUsedSpace() uint64 {
	if m != nil {
		return m.UsedSpace
	}
	return 0
}

func (m *User) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *User) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *User) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *User) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *User) GetSyncFil() int32 {
	if m != nil {
		return m.SyncFil
	}
	return 0
}

////////////////////////////////////////////////////////////////////////
// 磁盘空间
type DiskSpace struct {
	Total                uint64   `protobuf:"varint,1,opt,name=total,proto3" json:"total"`
	AdminUsed            uint64   `protobuf:"varint,2,opt,name=adminUsed,proto3" json:"adminUsed"`
	OtherAllocated       uint64   `protobuf:"varint,3,opt,name=otherAllocated,proto3" json:"otherAllocated"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiskSpace) Reset()         { *m = DiskSpace{} }
func (m *DiskSpace) String() string { return proto.CompactTextString(m) }
func (*DiskSpace) ProtoMessage()    {}
func (*DiskSpace) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{8}
}
func (m *DiskSpace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiskSpace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiskSpace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiskSpace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiskSpace.Merge(m, src)
}
func (m *DiskSpace) XXX_Size() int {
	return m.Size()
}
func (m *DiskSpace) XXX_DiscardUnknown() {
	xxx_messageInfo_DiskSpace.DiscardUnknown(m)
}

var xxx_messageInfo_DiskSpace proto.InternalMessageInfo

func (m *DiskSpace) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *DiskSpace) GetAdminUsed() uint64 {
	if m != nil {
		return m.AdminUsed
	}
	return 0
}

func (m *DiskSpace) GetOtherAllocated() uint64 {
	if m != nil {
		return m.OtherAllocated
	}
	return 0
}

////////////////////////////////////////////////////////////////////////
//  获取设备状态
// "/box/device/state/1.0.0"
type DeviceStateReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	PeerId               string   `protobuf:"bytes,2,opt,name=peerId,proto3" json:"peerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeviceStateReq) Reset()         { *m = DeviceStateReq{} }
func (m *DeviceStateReq) String() string { return proto.CompactTextString(m) }
func (*DeviceStateReq) ProtoMessage()    {}
func (*DeviceStateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{9}
}
func (m *DeviceStateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceStateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceStateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceStateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceStateReq.Merge(m, src)
}
func (m *DeviceStateReq) XXX_Size() int {
	return m.Size()
}
func (m *DeviceStateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceStateReq.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceStateReq proto.InternalMessageInfo

func (m *DeviceStateReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *DeviceStateReq) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

type DeviceStateResp struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code     `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	State                int32    `protobuf:"varint,3,opt,name=state,proto3" json:"state"`
	AdminName            string   `protobuf:"bytes,4,opt,name=adminName,proto3" json:"adminName"`
	AdminAvatar          []byte   `protobuf:"bytes,5,opt,name=adminAvatar,proto3" json:"adminAvatar"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeviceStateResp) Reset()         { *m = DeviceStateResp{} }
func (m *DeviceStateResp) String() string { return proto.CompactTextString(m) }
func (*DeviceStateResp) ProtoMessage()    {}
func (*DeviceStateResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{10}
}
func (m *DeviceStateResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceStateResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceStateResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceStateResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceStateResp.Merge(m, src)
}
func (m *DeviceStateResp) XXX_Size() int {
	return m.Size()
}
func (m *DeviceStateResp) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceStateResp.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceStateResp proto.InternalMessageInfo

func (m *DeviceStateResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *DeviceStateResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *DeviceStateResp) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *DeviceStateResp) GetAdminName() string {
	if m != nil {
		return m.AdminName
	}
	return ""
}

func (m *DeviceStateResp) GetAdminAvatar() []byte {
	if m != nil {
		return m.AdminAvatar
	}
	return nil
}

////////////////////////////////////////////////////////////////////////
//  激活设备
// "/box/activate/1.0.0"
type ActivateReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	PeerId               string   `protobuf:"bytes,2,opt,name=peerId,proto3" json:"peerId"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name"`
	Password             string   `protobuf:"bytes,4,opt,name=password,proto3" json:"password"`
	RandNonce            string   `protobuf:"bytes,5,opt,name=randNonce,proto3" json:"randNonce"`
	Signature            string   `protobuf:"bytes,6,opt,name=signature,proto3" json:"signature"`
	DeviceName           string   `protobuf:"bytes,7,opt,name=deviceName,proto3" json:"deviceName"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActivateReq) Reset()         { *m = ActivateReq{} }
func (m *ActivateReq) String() string { return proto.CompactTextString(m) }
func (*ActivateReq) ProtoMessage()    {}
func (*ActivateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{11}
}
func (m *ActivateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivateReq.Merge(m, src)
}
func (m *ActivateReq) XXX_Size() int {
	return m.Size()
}
func (m *ActivateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivateReq.DiscardUnknown(m)
}

var xxx_messageInfo_ActivateReq proto.InternalMessageInfo

func (m *ActivateReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *ActivateReq) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

func (m *ActivateReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ActivateReq) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *ActivateReq) GetRandNonce() string {
	if m != nil {
		return m.RandNonce
	}
	return ""
}

func (m *ActivateReq) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *ActivateReq) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

type ActivateResp struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code     `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string   `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	Token                string   `protobuf:"bytes,4,opt,name=token,proto3" json:"token"`
	UserInfo             *User    `protobuf:"bytes,5,opt,name=userInfo,proto3" json:"userInfo"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActivateResp) Reset()         { *m = ActivateResp{} }
func (m *ActivateResp) String() string { return proto.CompactTextString(m) }
func (*ActivateResp) ProtoMessage()    {}
func (*ActivateResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{12}
}
func (m *ActivateResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivateResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivateResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivateResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivateResp.Merge(m, src)
}
func (m *ActivateResp) XXX_Size() int {
	return m.Size()
}
func (m *ActivateResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivateResp.DiscardUnknown(m)
}

var xxx_messageInfo_ActivateResp proto.InternalMessageInfo

func (m *ActivateResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *ActivateResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *ActivateResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ActivateResp) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *ActivateResp) GetUserInfo() *User {
	if m != nil {
		return m.UserInfo
	}
	return nil
}

//  忘记密码
// "/box/forget_pass/1.0.0"
type ForgetPassReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	PeerId               string   `protobuf:"bytes,2,opt,name=peerId,proto3" json:"peerId"`
	Signature            string   `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature"`
	Name                 string   `protobuf:"bytes,4,opt,name=name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ForgetPassReq) Reset()         { *m = ForgetPassReq{} }
func (m *ForgetPassReq) String() string { return proto.CompactTextString(m) }
func (*ForgetPassReq) ProtoMessage()    {}
func (*ForgetPassReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{13}
}
func (m *ForgetPassReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForgetPassReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForgetPassReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForgetPassReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForgetPassReq.Merge(m, src)
}
func (m *ForgetPassReq) XXX_Size() int {
	return m.Size()
}
func (m *ForgetPassReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ForgetPassReq.DiscardUnknown(m)
}

var xxx_messageInfo_ForgetPassReq proto.InternalMessageInfo

func (m *ForgetPassReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *ForgetPassReq) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

func (m *ForgetPassReq) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *ForgetPassReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ForgetPassResp struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code     `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string   `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	Token                string   `protobuf:"bytes,4,opt,name=token,proto3" json:"token"`
	UserInfo             *User    `protobuf:"bytes,5,opt,name=userInfo,proto3" json:"userInfo"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ForgetPassResp) Reset()         { *m = ForgetPassResp{} }
func (m *ForgetPassResp) String() string { return proto.CompactTextString(m) }
func (*ForgetPassResp) ProtoMessage()    {}
func (*ForgetPassResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{14}
}
func (m *ForgetPassResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForgetPassResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForgetPassResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForgetPassResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForgetPassResp.Merge(m, src)
}
func (m *ForgetPassResp) XXX_Size() int {
	return m.Size()
}
func (m *ForgetPassResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ForgetPassResp.DiscardUnknown(m)
}

var xxx_messageInfo_ForgetPassResp proto.InternalMessageInfo

func (m *ForgetPassResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *ForgetPassResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *ForgetPassResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ForgetPassResp) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *ForgetPassResp) GetUserInfo() *User {
	if m != nil {
		return m.UserInfo
	}
	return nil
}

////////////////////////////////////////////////////////////////////////
// 登录
// "/box/login/1.0.0"
type LoginReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	PeerId               string   `protobuf:"bytes,2,opt,name=peerId,proto3" json:"peerId"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name"`
	Password             string   `protobuf:"bytes,4,opt,name=password,proto3" json:"password"`
	DeviceName           string   `protobuf:"bytes,5,opt,name=deviceName,proto3" json:"deviceName"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoginReq) Reset()         { *m = LoginReq{} }
func (m *LoginReq) String() string { return proto.CompactTextString(m) }
func (*LoginReq) ProtoMessage()    {}
func (*LoginReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{15}
}
func (m *LoginReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginReq.Merge(m, src)
}
func (m *LoginReq) XXX_Size() int {
	return m.Size()
}
func (m *LoginReq) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginReq.DiscardUnknown(m)
}

var xxx_messageInfo_LoginReq proto.InternalMessageInfo

func (m *LoginReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *LoginReq) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

func (m *LoginReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LoginReq) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *LoginReq) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

type LoginResp struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code     `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string   `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	Token                string   `protobuf:"bytes,4,opt,name=token,proto3" json:"token"`
	UserInfo             *User    `protobuf:"bytes,5,opt,name=userInfo,proto3" json:"userInfo"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoginResp) Reset()         { *m = LoginResp{} }
func (m *LoginResp) String() string { return proto.CompactTextString(m) }
func (*LoginResp) ProtoMessage()    {}
func (*LoginResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{16}
}
func (m *LoginResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginResp.Merge(m, src)
}
func (m *LoginResp) XXX_Size() int {
	return m.Size()
}
func (m *LoginResp) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginResp.DiscardUnknown(m)
}

var xxx_messageInfo_LoginResp proto.InternalMessageInfo

func (m *LoginResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *LoginResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *LoginResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *LoginResp) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *LoginResp) GetUserInfo() *User {
	if m != nil {
		return m.UserInfo
	}
	return nil
}

////////////////////////////////////////////////////////////////////////
// 添加用户
// "/box/user/add/1.0.0"
type AddUserReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name"`
	Password             string   `protobuf:"bytes,4,opt,name=password,proto3" json:"password"`
	Space                uint64   `protobuf:"varint,5,opt,name=space,proto3" json:"space"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddUserReq) Reset()         { *m = AddUserReq{} }
func (m *AddUserReq) String() string { return proto.CompactTextString(m) }
func (*AddUserReq) ProtoMessage()    {}
func (*AddUserReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{17}
}
func (m *AddUserReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddUserReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddUserReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddUserReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddUserReq.Merge(m, src)
}
func (m *AddUserReq) XXX_Size() int {
	return m.Size()
}
func (m *AddUserReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AddUserReq.DiscardUnknown(m)
}

var xxx_messageInfo_AddUserReq proto.InternalMessageInfo

func (m *AddUserReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *AddUserReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *AddUserReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AddUserReq) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *AddUserReq) GetSpace() uint64 {
	if m != nil {
		return m.Space
	}
	return 0
}

////////////////////////////////////////////////////////////////////////
// 获取用户信息
// "/box/user/info/1.0.0"
type UserInfoReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserInfoReq) Reset()         { *m = UserInfoReq{} }
func (m *UserInfoReq) String() string { return proto.CompactTextString(m) }
func (*UserInfoReq) ProtoMessage()    {}
func (*UserInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{18}
}
func (m *UserInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserInfoReq.Merge(m, src)
}
func (m *UserInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *UserInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UserInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_UserInfoReq proto.InternalMessageInfo

func (m *UserInfoReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *UserInfoReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type UserInfoResp struct {
	Nonce                uint32     `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code       `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string     `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	User                 *User      `protobuf:"bytes,4,opt,name=user,proto3" json:"user"`
	Space                *DiskSpace `protobuf:"bytes,5,opt,name=space,proto3" json:"space"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *UserInfoResp) Reset()         { *m = UserInfoResp{} }
func (m *UserInfoResp) String() string { return proto.CompactTextString(m) }
func (*UserInfoResp) ProtoMessage()    {}
func (*UserInfoResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{19}
}
func (m *UserInfoResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserInfoResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserInfoResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserInfoResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserInfoResp.Merge(m, src)
}
func (m *UserInfoResp) XXX_Size() int {
	return m.Size()
}
func (m *UserInfoResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UserInfoResp.DiscardUnknown(m)
}

var xxx_messageInfo_UserInfoResp proto.InternalMessageInfo

func (m *UserInfoResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *UserInfoResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *UserInfoResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *UserInfoResp) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *UserInfoResp) GetSpace() *DiskSpace {
	if m != nil {
		return m.Space
	}
	return nil
}

////////////////////////////////////////////////////////////////////////
// 获取用户列表
// "/box/user/list/1.0.0"
type UserListReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserListReq) Reset()         { *m = UserListReq{} }
func (m *UserListReq) String() string { return proto.CompactTextString(m) }
func (*UserListReq) ProtoMessage()    {}
func (*UserListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{20}
}
func (m *UserListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserListReq.Merge(m, src)
}
func (m *UserListReq) XXX_Size() int {
	return m.Size()
}
func (m *UserListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UserListReq.DiscardUnknown(m)
}

var xxx_messageInfo_UserListReq proto.InternalMessageInfo

func (m *UserListReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *UserListReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type UserListResp struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code     `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string   `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	User                 []*User  `protobuf:"bytes,4,rep,name=user,proto3" json:"user"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserListResp) Reset()         { *m = UserListResp{} }
func (m *UserListResp) String() string { return proto.CompactTextString(m) }
func (*UserListResp) ProtoMessage()    {}
func (*UserListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{21}
}
func (m *UserListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserListResp.Merge(m, src)
}
func (m *UserListResp) XXX_Size() int {
	return m.Size()
}
func (m *UserListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UserListResp.DiscardUnknown(m)
}

var xxx_messageInfo_UserListResp proto.InternalMessageInfo

func (m *UserListResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *UserListResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *UserListResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *UserListResp) GetUser() []*User {
	if m != nil {
		return m.User
	}
	return nil
}

///////////////////////////////////////////////////////////////////////
// 修改自己的密码
// "/box/user/update_pass/1.0.0"
type UpdatePasswordReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	OldPass              string   `protobuf:"bytes,3,opt,name=oldPass,proto3" json:"oldPass"`
	NewPass              string   `protobuf:"bytes,4,opt,name=newPass,proto3" json:"newPass"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdatePasswordReq) Reset()         { *m = UpdatePasswordReq{} }
func (m *UpdatePasswordReq) String() string { return proto.CompactTextString(m) }
func (*UpdatePasswordReq) ProtoMessage()    {}
func (*UpdatePasswordReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{22}
}
func (m *UpdatePasswordReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdatePasswordReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdatePasswordReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdatePasswordReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdatePasswordReq.Merge(m, src)
}
func (m *UpdatePasswordReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdatePasswordReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdatePasswordReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdatePasswordReq proto.InternalMessageInfo

func (m *UpdatePasswordReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *UpdatePasswordReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *UpdatePasswordReq) GetOldPass() string {
	if m != nil {
		return m.OldPass
	}
	return ""
}

func (m *UpdatePasswordReq) GetNewPass() string {
	if m != nil {
		return m.NewPass
	}
	return ""
}

///////////////////////////////////////////////////////////////////////
// 修改自己的昵称
// "/box/user/rename/1.0.0"
type UserRenameReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserRenameReq) Reset()         { *m = UserRenameReq{} }
func (m *UserRenameReq) String() string { return proto.CompactTextString(m) }
func (*UserRenameReq) ProtoMessage()    {}
func (*UserRenameReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{23}
}
func (m *UserRenameReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserRenameReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserRenameReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserRenameReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRenameReq.Merge(m, src)
}
func (m *UserRenameReq) XXX_Size() int {
	return m.Size()
}
func (m *UserRenameReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRenameReq.DiscardUnknown(m)
}

var xxx_messageInfo_UserRenameReq proto.InternalMessageInfo

func (m *UserRenameReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *UserRenameReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *UserRenameReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

////////////////////////////////////////////////////////////////////////
// 获取用户头像
// "/box/user/avatar/get/1.0.0"
type GetUserAvatarReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	UserId               int32    `protobuf:"varint,3,opt,name=userId,proto3" json:"userId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetUserAvatarReq) Reset()         { *m = GetUserAvatarReq{} }
func (m *GetUserAvatarReq) String() string { return proto.CompactTextString(m) }
func (*GetUserAvatarReq) ProtoMessage()    {}
func (*GetUserAvatarReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{24}
}
func (m *GetUserAvatarReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUserAvatarReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUserAvatarReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUserAvatarReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserAvatarReq.Merge(m, src)
}
func (m *GetUserAvatarReq) XXX_Size() int {
	return m.Size()
}
func (m *GetUserAvatarReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserAvatarReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserAvatarReq proto.InternalMessageInfo

func (m *GetUserAvatarReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *GetUserAvatarReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *GetUserAvatarReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type GetUserAvatarResp struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code     `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string   `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	AvatarData           []byte   `protobuf:"bytes,4,opt,name=avatarData,proto3" json:"avatarData"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetUserAvatarResp) Reset()         { *m = GetUserAvatarResp{} }
func (m *GetUserAvatarResp) String() string { return proto.CompactTextString(m) }
func (*GetUserAvatarResp) ProtoMessage()    {}
func (*GetUserAvatarResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{25}
}
func (m *GetUserAvatarResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUserAvatarResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUserAvatarResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUserAvatarResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserAvatarResp.Merge(m, src)
}
func (m *GetUserAvatarResp) XXX_Size() int {
	return m.Size()
}
func (m *GetUserAvatarResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserAvatarResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserAvatarResp proto.InternalMessageInfo

func (m *GetUserAvatarResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *GetUserAvatarResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *GetUserAvatarResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *GetUserAvatarResp) GetAvatarData() []byte {
	if m != nil {
		return m.AvatarData
	}
	return nil
}

////////////////////////////////////////////////////////////////////////
// 更新用户头像
// "/box/user/avatar/update/1.0.0"
type UpdateUserAvatarReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	AvatarData           []byte   `protobuf:"bytes,3,opt,name=avatarData,proto3" json:"avatarData"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateUserAvatarReq) Reset()         { *m = UpdateUserAvatarReq{} }
func (m *UpdateUserAvatarReq) String() string { return proto.CompactTextString(m) }
func (*UpdateUserAvatarReq) ProtoMessage()    {}
func (*UpdateUserAvatarReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{26}
}
func (m *UpdateUserAvatarReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateUserAvatarReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateUserAvatarReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateUserAvatarReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateUserAvatarReq.Merge(m, src)
}
func (m *UpdateUserAvatarReq) XXX_Size() int {
	return m.Size()
}
func (m *UpdateUserAvatarReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateUserAvatarReq.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateUserAvatarReq proto.InternalMessageInfo

func (m *UpdateUserAvatarReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *UpdateUserAvatarReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *UpdateUserAvatarReq) GetAvatarData() []byte {
	if m != nil {
		return m.AvatarData
	}
	return nil
}

///////////////////////////////////////////////////////////////////////
// 管理员重置他人的密码
// "/box/user/reset_pass/1.0.0"
type ResetPasswordReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	UserId               uint32   `protobuf:"varint,3,opt,name=userId,proto3" json:"userId"`
	NewPass              string   `protobuf:"bytes,4,opt,name=newPass,proto3" json:"newPass"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResetPasswordReq) Reset()         { *m = ResetPasswordReq{} }
func (m *ResetPasswordReq) String() string { return proto.CompactTextString(m) }
func (*ResetPasswordReq) ProtoMessage()    {}
func (*ResetPasswordReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{27}
}
func (m *ResetPasswordReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetPasswordReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResetPasswordReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResetPasswordReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetPasswordReq.Merge(m, src)
}
func (m *ResetPasswordReq) XXX_Size() int {
	return m.Size()
}
func (m *ResetPasswordReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetPasswordReq.DiscardUnknown(m)
}

var xxx_messageInfo_ResetPasswordReq proto.InternalMessageInfo

func (m *ResetPasswordReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *ResetPasswordReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *ResetPasswordReq) GetUserId() uint32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ResetPasswordReq) GetNewPass() string {
	if m != nil {
		return m.NewPass
	}
	return ""
}

///////////////////////////////////////////////////////////////////////
// 管理员禁用/启用子账号
// "/box/user/enable/1.0.0"
type EnableUserReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	UserId               uint32   `protobuf:"varint,3,opt,name=userId,proto3" json:"userId"`
	Enable               bool     `protobuf:"varint,4,opt,name=enable,proto3" json:"enable"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnableUserReq) Reset()         { *m = EnableUserReq{} }
func (m *EnableUserReq) String() string { return proto.CompactTextString(m) }
func (*EnableUserReq) ProtoMessage()    {}
func (*EnableUserReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{28}
}
func (m *EnableUserReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnableUserReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnableUserReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnableUserReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnableUserReq.Merge(m, src)
}
func (m *EnableUserReq) XXX_Size() int {
	return m.Size()
}
func (m *EnableUserReq) XXX_DiscardUnknown() {
	xxx_messageInfo_EnableUserReq.DiscardUnknown(m)
}

var xxx_messageInfo_EnableUserReq proto.InternalMessageInfo

func (m *EnableUserReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *EnableUserReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *EnableUserReq) GetUserId() uint32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *EnableUserReq) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

///////////////////////////////////////////////////////////////////////
// 管理员删除子账号
// "/box/user/delete/1.0.0"
type DeleteUserReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	UserId               uint32   `protobuf:"varint,3,opt,name=userId,proto3" json:"userId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteUserReq) Reset()         { *m = DeleteUserReq{} }
func (m *DeleteUserReq) String() string { return proto.CompactTextString(m) }
func (*DeleteUserReq) ProtoMessage()    {}
func (*DeleteUserReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{29}
}
func (m *DeleteUserReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteUserReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteUserReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteUserReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteUserReq.Merge(m, src)
}
func (m *DeleteUserReq) XXX_Size() int {
	return m.Size()
}
func (m *DeleteUserReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteUserReq.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteUserReq proto.InternalMessageInfo

func (m *DeleteUserReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *DeleteUserReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *DeleteUserReq) GetUserId() uint32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

///////////////////////////////////////////////////////////////////////
// 管理员调整子账号空间
// "/box/user/change_space/1.0.0"
type ChangeSpaceReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	UserId               uint32   `protobuf:"varint,3,opt,name=userId,proto3" json:"userId"`
	Space                uint64   `protobuf:"varint,4,opt,name=space,proto3" json:"space"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChangeSpaceReq) Reset()         { *m = ChangeSpaceReq{} }
func (m *ChangeSpaceReq) String() string { return proto.CompactTextString(m) }
func (*ChangeSpaceReq) ProtoMessage()    {}
func (*ChangeSpaceReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{30}
}
func (m *ChangeSpaceReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeSpaceReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangeSpaceReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangeSpaceReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeSpaceReq.Merge(m, src)
}
func (m *ChangeSpaceReq) XXX_Size() int {
	return m.Size()
}
func (m *ChangeSpaceReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeSpaceReq.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeSpaceReq proto.InternalMessageInfo

func (m *ChangeSpaceReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *ChangeSpaceReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *ChangeSpaceReq) GetUserId() uint32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ChangeSpaceReq) GetSpace() uint64 {
	if m != nil {
		return m.Space
	}
	return 0
}

///////////////////////////////////////////////////////////////////////
// 扫码登录-APP端扫描二维码 （APP => 服务器）
// "/box/qrcode/scan/1.0.0"
// Http Post Json : http://122.9.61.5:16516/v1/scan_qrcode
type ScanQrcodeReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Qrcode               string   `protobuf:"bytes,2,opt,name=qrcode,proto3" json:"qrcode"`
	PeerId               string   `protobuf:"bytes,3,opt,name=peerId,proto3" json:"peerId"`
	Token                string   `protobuf:"bytes,4,opt,name=token,proto3" json:"token"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ScanQrcodeReq) Reset()         { *m = ScanQrcodeReq{} }
func (m *ScanQrcodeReq) String() string { return proto.CompactTextString(m) }
func (*ScanQrcodeReq) ProtoMessage()    {}
func (*ScanQrcodeReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{31}
}
func (m *ScanQrcodeReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanQrcodeReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScanQrcodeReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScanQrcodeReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanQrcodeReq.Merge(m, src)
}
func (m *ScanQrcodeReq) XXX_Size() int {
	return m.Size()
}
func (m *ScanQrcodeReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanQrcodeReq.DiscardUnknown(m)
}

var xxx_messageInfo_ScanQrcodeReq proto.InternalMessageInfo

func (m *ScanQrcodeReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *ScanQrcodeReq) GetQrcode() string {
	if m != nil {
		return m.Qrcode
	}
	return ""
}

func (m *ScanQrcodeReq) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

func (m *ScanQrcodeReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

////////////////////////////////////////////////////////////////////////
// 扫码登录-PC端获取盒子地址  (PC => 服务器)
// "/box/qrcode/get_token/1.0.0"
// Http Post Json : http://122.9.61.5:16516/v1/qrcode_token
type GetTokenByQrcodeReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Qrcode               string   `protobuf:"bytes,2,opt,name=qrcode,proto3" json:"qrcode"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTokenByQrcodeReq) Reset()         { *m = GetTokenByQrcodeReq{} }
func (m *GetTokenByQrcodeReq) String() string { return proto.CompactTextString(m) }
func (*GetTokenByQrcodeReq) ProtoMessage()    {}
func (*GetTokenByQrcodeReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{32}
}
func (m *GetTokenByQrcodeReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTokenByQrcodeReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTokenByQrcodeReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTokenByQrcodeReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTokenByQrcodeReq.Merge(m, src)
}
func (m *GetTokenByQrcodeReq) XXX_Size() int {
	return m.Size()
}
func (m *GetTokenByQrcodeReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTokenByQrcodeReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetTokenByQrcodeReq proto.InternalMessageInfo

func (m *GetTokenByQrcodeReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *GetTokenByQrcodeReq) GetQrcode() string {
	if m != nil {
		return m.Qrcode
	}
	return ""
}

type GetTokenByQrcodeResp struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code     `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string   `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	Token                string   `protobuf:"bytes,4,opt,name=token,proto3" json:"token"`
	PeerId               string   `protobuf:"bytes,5,opt,name=peerId,proto3" json:"peerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetTokenByQrcodeResp) Reset()         { *m = GetTokenByQrcodeResp{} }
func (m *GetTokenByQrcodeResp) String() string { return proto.CompactTextString(m) }
func (*GetTokenByQrcodeResp) ProtoMessage()    {}
func (*GetTokenByQrcodeResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{33}
}
func (m *GetTokenByQrcodeResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTokenByQrcodeResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTokenByQrcodeResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTokenByQrcodeResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTokenByQrcodeResp.Merge(m, src)
}
func (m *GetTokenByQrcodeResp) XXX_Size() int {
	return m.Size()
}
func (m *GetTokenByQrcodeResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTokenByQrcodeResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetTokenByQrcodeResp proto.InternalMessageInfo

func (m *GetTokenByQrcodeResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *GetTokenByQrcodeResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *GetTokenByQrcodeResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *GetTokenByQrcodeResp) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *GetTokenByQrcodeResp) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

type FileItem struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name"`
	Size_                int64    `protobuf:"varint,3,opt,name=size,proto3" json:"size"`
	IsFolder             bool     `protobuf:"varint,4,opt,name=isFolder,proto3" json:"isFolder"`
	CreatedAt            int64    `protobuf:"varint,5,opt,name=createdAt,proto3" json:"createdAt"`
	UpdatedAt            int64    `protobuf:"varint,6,opt,name=updatedAt,proto3" json:"updatedAt"`
	Md5                  string   `protobuf:"bytes,7,opt,name=md5,proto3" json:"md5"`
	Star                 bool     `protobuf:"varint,8,opt,name=star,proto3" json:"star"`
	Share                bool     `protobuf:"varint,9,opt,name=share,proto3" json:"share"`
	SubFiles             int32    `protobuf:"varint,10,opt,name=subFiles,proto3" json:"subFiles"`
	Kind                 string   `protobuf:"bytes,11,opt,name=kind,proto3" json:"kind"`
	ShareCount           int32    `protobuf:"varint,12,opt,name=shareCount,proto3" json:"shareCount"`
	Ext                  string   `protobuf:"bytes,13,opt,name=ext,proto3" json:"ext"`
	ParentId             string   `protobuf:"bytes,14,opt,name=parentId,proto3" json:"parentId"`
	ParentName           string   `protobuf:"bytes,15,opt,name=parentName,proto3" json:"parentName"`
	IsSystem             int32    `protobuf:"varint,16,opt,name=isSystem,proto3" json:"isSystem"`
	Cid                  string   `protobuf:"bytes,17,opt,name=cid,proto3" json:"cid"`
	FormDevice           string   `protobuf:"bytes,18,opt,name=formDevice,proto3" json:"formDevice"`
	StartAt              int64    `protobuf:"varint,19,opt,name=startAt,proto3" json:"startAt"`
	EndAt                int64    `protobuf:"varint,20,opt,name=endAt,proto3" json:"endAt"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileItem) Reset()         { *m = FileItem{} }
func (m *FileItem) String() string { return proto.CompactTextString(m) }
func (*FileItem) ProtoMessage()    {}
func (*FileItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{34}
}
func (m *FileItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileItem.Merge(m, src)
}
func (m *FileItem) XXX_Size() int {
	return m.Size()
}
func (m *FileItem) XXX_DiscardUnknown() {
	xxx_messageInfo_FileItem.DiscardUnknown(m)
}

var xxx_messageInfo_FileItem proto.InternalMessageInfo

func (m *FileItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *FileItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FileItem) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *FileItem) GetIsFolder() bool {
	if m != nil {
		return m.IsFolder
	}
	return false
}

func (m *FileItem) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *FileItem) GetUpdatedAt() int64 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

func (m *FileItem) GetMd5() string {
	if m != nil {
		return m.Md5
	}
	return ""
}

func (m *FileItem) GetStar() bool {
	if m != nil {
		return m.Star
	}
	return false
}

func (m *FileItem) GetShare() bool {
	if m != nil {
		return m.Share
	}
	return false
}

func (m *FileItem) GetSubFiles() int32 {
	if m != nil {
		return m.SubFiles
	}
	return 0
}

func (m *FileItem) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *FileItem) GetShareCount() int32 {
	if m != nil {
		return m.ShareCount
	}
	return 0
}

func (m *FileItem) GetExt() string {
	if m != nil {
		return m.Ext
	}
	return ""
}

func (m *FileItem) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *FileItem) GetParentName() string {
	if m != nil {
		return m.ParentName
	}
	return ""
}

func (m *FileItem) GetIsSystem() int32 {
	if m != nil {
		return m.IsSystem
	}
	return 0
}

func (m *FileItem) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

func (m *FileItem) GetFormDevice() string {
	if m != nil {
		return m.FormDevice
	}
	return ""
}

func (m *FileItem) GetStartAt() int64 {
	if m != nil {
		return m.StartAt
	}
	return 0
}

func (m *FileItem) GetEndAt() int64 {
	if m != nil {
		return m.EndAt
	}
	return 0
}

///////////////////////////////////////////////////////////////////////
// 新建文件夹
// "/box/file/new_folder/1.0.0"
type NewFolderReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	Id                   string   `protobuf:"bytes,3,opt,name=id,proto3" json:"id"`
	Name                 string   `protobuf:"bytes,4,opt,name=name,proto3" json:"name"`
	ParentId             string   `protobuf:"bytes,5,opt,name=parentId,proto3" json:"parentId"`
	IsSystem             int32    `protobuf:"varint,6,opt,name=isSystem,proto3" json:"isSystem"`
	FormDevice           string   `protobuf:"bytes,7,opt,name=formDevice,proto3" json:"formDevice"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NewFolderReq) Reset()         { *m = NewFolderReq{} }
func (m *NewFolderReq) String() string { return proto.CompactTextString(m) }
func (*NewFolderReq) ProtoMessage()    {}
func (*NewFolderReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{35}
}
func (m *NewFolderReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewFolderReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewFolderReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewFolderReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewFolderReq.Merge(m, src)
}
func (m *NewFolderReq) XXX_Size() int {
	return m.Size()
}
func (m *NewFolderReq) XXX_DiscardUnknown() {
	xxx_messageInfo_NewFolderReq.DiscardUnknown(m)
}

var xxx_messageInfo_NewFolderReq proto.InternalMessageInfo

func (m *NewFolderReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *NewFolderReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *NewFolderReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NewFolderReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NewFolderReq) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *NewFolderReq) GetIsSystem() int32 {
	if m != nil {
		return m.IsSystem
	}
	return 0
}

func (m *NewFolderReq) GetFormDevice() string {
	if m != nil {
		return m.FormDevice
	}
	return ""
}

type NewFolderResp struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code     `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Id                   string   `protobuf:"bytes,3,opt,name=id,proto3" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NewFolderResp) Reset()         { *m = NewFolderResp{} }
func (m *NewFolderResp) String() string { return proto.CompactTextString(m) }
func (*NewFolderResp) ProtoMessage()    {}
func (*NewFolderResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{36}
}
func (m *NewFolderResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewFolderResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewFolderResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewFolderResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewFolderResp.Merge(m, src)
}
func (m *NewFolderResp) XXX_Size() int {
	return m.Size()
}
func (m *NewFolderResp) XXX_DiscardUnknown() {
	xxx_messageInfo_NewFolderResp.DiscardUnknown(m)
}

var xxx_messageInfo_NewFolderResp proto.InternalMessageInfo

func (m *NewFolderResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *NewFolderResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *NewFolderResp) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

///////////////////////////////////////////////////////////////////////
// 文件上传
// "/box/file/upload/1.0.0"
type UploadFileReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name"`
	Id                   string   `protobuf:"bytes,4,opt,name=id,proto3" json:"id"`
	ParentId             string   `protobuf:"bytes,5,opt,name=parentId,proto3" json:"parentId"`
	Size_                int64    `protobuf:"varint,6,opt,name=size,proto3" json:"size"`
	BytesFrom            int64    `protobuf:"varint,7,opt,name=bytes_from,json=bytesFrom,proto3" json:"bytes_from"`
	Data                 []byte   `protobuf:"bytes,8,opt,name=data,proto3" json:"data"`
	Md5                  string   `protobuf:"bytes,9,opt,name=md5,proto3" json:"md5"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadFileReq) Reset()         { *m = UploadFileReq{} }
func (m *UploadFileReq) String() string { return proto.CompactTextString(m) }
func (*UploadFileReq) ProtoMessage()    {}
func (*UploadFileReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{37}
}
func (m *UploadFileReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadFileReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadFileReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadFileReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadFileReq.Merge(m, src)
}
func (m *UploadFileReq) XXX_Size() int {
	return m.Size()
}
func (m *UploadFileReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadFileReq.DiscardUnknown(m)
}

var xxx_messageInfo_UploadFileReq proto.InternalMessageInfo

func (m *UploadFileReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *UploadFileReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *UploadFileReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UploadFileReq) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *UploadFileReq) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *UploadFileReq) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *UploadFileReq) GetBytesFrom() int64 {
	if m != nil {
		return m.BytesFrom
	}
	return 0
}

func (m *UploadFileReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *UploadFileReq) GetMd5() string {
	if m != nil {
		return m.Md5
	}
	return ""
}

///////////////////////////////////////////////////////////////////////
// 文件下载
// "/box/file/download/1.0.0"
type DownloadFileReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	FileId               string   `protobuf:"bytes,3,opt,name=fileId,proto3" json:"fileId"`
	BytesFrom            int64    `protobuf:"varint,4,opt,name=bytes_from,json=bytesFrom,proto3" json:"bytes_from"`
	BytesCount           int64    `protobuf:"varint,5,opt,name=bytes_count,json=bytesCount,proto3" json:"bytes_count"`
	UserId               int32    `protobuf:"varint,6,opt,name=userId,proto3" json:"userId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownloadFileReq) Reset()         { *m = DownloadFileReq{} }
func (m *DownloadFileReq) String() string { return proto.CompactTextString(m) }
func (*DownloadFileReq) ProtoMessage()    {}
func (*DownloadFileReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{38}
}
func (m *DownloadFileReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadFileReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadFileReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadFileReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadFileReq.Merge(m, src)
}
func (m *DownloadFileReq) XXX_Size() int {
	return m.Size()
}
func (m *DownloadFileReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadFileReq.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadFileReq proto.InternalMessageInfo

func (m *DownloadFileReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *DownloadFileReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *DownloadFileReq) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *DownloadFileReq) GetBytesFrom() int64 {
	if m != nil {
		return m.BytesFrom
	}
	return 0
}

func (m *DownloadFileReq) GetBytesCount() int64 {
	if m != nil {
		return m.BytesCount
	}
	return 0
}

func (m *DownloadFileReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type DownloadFileResp struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code     `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string   `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	Name                 string   `protobuf:"bytes,4,opt,name=name,proto3" json:"name"`
	FileSize             int64    `protobuf:"varint,5,opt,name=fileSize,proto3" json:"fileSize"`
	Data                 []byte   `protobuf:"bytes,6,opt,name=data,proto3" json:"data"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownloadFileResp) Reset()         { *m = DownloadFileResp{} }
func (m *DownloadFileResp) String() string { return proto.CompactTextString(m) }
func (*DownloadFileResp) ProtoMessage()    {}
func (*DownloadFileResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{39}
}
func (m *DownloadFileResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadFileResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadFileResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadFileResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadFileResp.Merge(m, src)
}
func (m *DownloadFileResp) XXX_Size() int {
	return m.Size()
}
func (m *DownloadFileResp) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadFileResp.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadFileResp proto.InternalMessageInfo

func (m *DownloadFileResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *DownloadFileResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *DownloadFileResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *DownloadFileResp) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DownloadFileResp) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *DownloadFileResp) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

///////////////////////////////////////////////////////////////////////
// 文件（夹）列表
// "/box/file/list/1.0.0"
type FileListReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	ParentId             string   `protobuf:"bytes,3,opt,name=parentId,proto3" json:"parentId"`
	DirMask              int32    `protobuf:"varint,4,opt,name=dirMask,proto3" json:"dirMask"`
	FileType             int32    `protobuf:"varint,5,opt,name=fileType,proto3" json:"fileType"`
	StarMask             int32    `protobuf:"varint,6,opt,name=starMask,proto3" json:"starMask"`
	Keyword              string   `protobuf:"bytes,7,opt,name=keyword,proto3" json:"keyword"`
	Order                int32    `protobuf:"varint,8,opt,name=order,proto3" json:"order"`
	Offset               int32    `protobuf:"varint,9,opt,name=offset,proto3" json:"offset"`
	Limit                int32    `protobuf:"varint,10,opt,name=limit,proto3" json:"limit"`
	IsEqual              int32    `protobuf:"varint,11,opt,name=isEqual,proto3" json:"isEqual"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileListReq) Reset()         { *m = FileListReq{} }
func (m *FileListReq) String() string { return proto.CompactTextString(m) }
func (*FileListReq) ProtoMessage()    {}
func (*FileListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{40}
}
func (m *FileListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileListReq.Merge(m, src)
}
func (m *FileListReq) XXX_Size() int {
	return m.Size()
}
func (m *FileListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FileListReq.DiscardUnknown(m)
}

var xxx_messageInfo_FileListReq proto.InternalMessageInfo

func (m *FileListReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *FileListReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *FileListReq) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *FileListReq) GetDirMask() int32 {
	if m != nil {
		return m.DirMask
	}
	return 0
}

func (m *FileListReq) GetFileType() int32 {
	if m != nil {
		return m.FileType
	}
	return 0
}

func (m *FileListReq) GetStarMask() int32 {
	if m != nil {
		return m.StarMask
	}
	return 0
}

func (m *FileListReq) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *FileListReq) GetOrder() int32 {
	if m != nil {
		return m.Order
	}
	return 0
}

func (m *FileListReq) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *FileListReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *FileListReq) GetIsEqual() int32 {
	if m != nil {
		return m.IsEqual
	}
	return 0
}

type FileListResp struct {
	Nonce                uint32      `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code        `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string      `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	Total                int32       `protobuf:"varint,4,opt,name=total,proto3" json:"total"`
	Files                []*FileItem `protobuf:"bytes,5,rep,name=files,proto3" json:"files"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *FileListResp) Reset()         { *m = FileListResp{} }
func (m *FileListResp) String() string { return proto.CompactTextString(m) }
func (*FileListResp) ProtoMessage()    {}
func (*FileListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{41}
}
func (m *FileListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileListResp.Merge(m, src)
}
func (m *FileListResp) XXX_Size() int {
	return m.Size()
}
func (m *FileListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_FileListResp.DiscardUnknown(m)
}

var xxx_messageInfo_FileListResp proto.InternalMessageInfo

func (m *FileListResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *FileListResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *FileListResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *FileListResp) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *FileListResp) GetFiles() []*FileItem {
	if m != nil {
		return m.Files
	}
	return nil
}

///////////////////////////////////////////////////////////////////////
// 修改文件(夹)名
// "/box/file/rename/1.0.0"
type FileRenameReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	FileId               string   `protobuf:"bytes,3,opt,name=fileId,proto3" json:"fileId"`
	Name                 string   `protobuf:"bytes,4,opt,name=name,proto3" json:"name"`
	ParentId             string   `protobuf:"bytes,5,opt,name=parentId,proto3" json:"parentId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileRenameReq) Reset()         { *m = FileRenameReq{} }
func (m *FileRenameReq) String() string { return proto.CompactTextString(m) }
func (*FileRenameReq) ProtoMessage()    {}
func (*FileRenameReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{42}
}
func (m *FileRenameReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileRenameReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileRenameReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileRenameReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileRenameReq.Merge(m, src)
}
func (m *FileRenameReq) XXX_Size() int {
	return m.Size()
}
func (m *FileRenameReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FileRenameReq.DiscardUnknown(m)
}

var xxx_messageInfo_FileRenameReq proto.InternalMessageInfo

func (m *FileRenameReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *FileRenameReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *FileRenameReq) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *FileRenameReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FileRenameReq) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

///////////////////////////////////////////////////////////////////////
// 删除文件（夹）
// "/box/file/delete/1.0.0"
type FileDeleteReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	FileIds              []string `protobuf:"bytes,3,rep,name=fileIds,proto3" json:"fileIds"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileDeleteReq) Reset()         { *m = FileDeleteReq{} }
func (m *FileDeleteReq) String() string { return proto.CompactTextString(m) }
func (*FileDeleteReq) ProtoMessage()    {}
func (*FileDeleteReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{43}
}
func (m *FileDeleteReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileDeleteReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileDeleteReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileDeleteReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileDeleteReq.Merge(m, src)
}
func (m *FileDeleteReq) XXX_Size() int {
	return m.Size()
}
func (m *FileDeleteReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FileDeleteReq.DiscardUnknown(m)
}

var xxx_messageInfo_FileDeleteReq proto.InternalMessageInfo

func (m *FileDeleteReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *FileDeleteReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *FileDeleteReq) GetFileIds() []string {
	if m != nil {
		return m.FileIds
	}
	return nil
}

///////////////////////////////////////////////////////////////////////
// 移动文件（夹）
// "/box/file/move/1.0.0"
type FileMoveReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	FileId               string   `protobuf:"bytes,3,opt,name=fileId,proto3" json:"fileId"`
	NewParentId          string   `protobuf:"bytes,4,opt,name=newParentId,proto3" json:"newParentId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileMoveReq) Reset()         { *m = FileMoveReq{} }
func (m *FileMoveReq) String() string { return proto.CompactTextString(m) }
func (*FileMoveReq) ProtoMessage()    {}
func (*FileMoveReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{44}
}
func (m *FileMoveReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileMoveReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileMoveReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileMoveReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileMoveReq.Merge(m, src)
}
func (m *FileMoveReq) XXX_Size() int {
	return m.Size()
}
func (m *FileMoveReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FileMoveReq.DiscardUnknown(m)
}

var xxx_messageInfo_FileMoveReq proto.InternalMessageInfo

func (m *FileMoveReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *FileMoveReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *FileMoveReq) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *FileMoveReq) GetNewParentId() string {
	if m != nil {
		return m.NewParentId
	}
	return ""
}

///////////////////////////////////////////////////////////////////////
//  复制文件（夹）
// "/box/file/copy/1.0.0"
type FileCopyReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	FileId               string   `protobuf:"bytes,3,opt,name=fileId,proto3" json:"fileId"`
	NewParentId          string   `protobuf:"bytes,4,opt,name=newParentId,proto3" json:"newParentId"`
	NewFileId            string   `protobuf:"bytes,5,opt,name=newFileId,proto3" json:"newFileId"`
	NewFileName          string   `protobuf:"bytes,6,opt,name=newFileName,proto3" json:"newFileName"`
	UserId               int32    `protobuf:"varint,7,opt,name=userId,proto3" json:"userId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileCopyReq) Reset()         { *m = FileCopyReq{} }
func (m *FileCopyReq) String() string { return proto.CompactTextString(m) }
func (*FileCopyReq) ProtoMessage()    {}
func (*FileCopyReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{45}
}
func (m *FileCopyReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileCopyReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileCopyReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileCopyReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileCopyReq.Merge(m, src)
}
func (m *FileCopyReq) XXX_Size() int {
	return m.Size()
}
func (m *FileCopyReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FileCopyReq.DiscardUnknown(m)
}

var xxx_messageInfo_FileCopyReq proto.InternalMessageInfo

func (m *FileCopyReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *FileCopyReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *FileCopyReq) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *FileCopyReq) GetNewParentId() string {
	if m != nil {
		return m.NewParentId
	}
	return ""
}

func (m *FileCopyReq) GetNewFileId() string {
	if m != nil {
		return m.NewFileId
	}
	return ""
}

func (m *FileCopyReq) GetNewFileName() string {
	if m != nil {
		return m.NewFileName
	}
	return ""
}

func (m *FileCopyReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

///////////////////////////////////////////////////////////////////////
// 收藏文件（夹）
// "/box/file/star/1.0.0"
type FileStarReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	FileIds              []string `protobuf:"bytes,3,rep,name=fileIds,proto3" json:"fileIds"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileStarReq) Reset()         { *m = FileStarReq{} }
func (m *FileStarReq) String() string { return proto.CompactTextString(m) }
func (*FileStarReq) ProtoMessage()    {}
func (*FileStarReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{46}
}
func (m *FileStarReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileStarReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileStarReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileStarReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileStarReq.Merge(m, src)
}
func (m *FileStarReq) XXX_Size() int {
	return m.Size()
}
func (m *FileStarReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FileStarReq.DiscardUnknown(m)
}

var xxx_messageInfo_FileStarReq proto.InternalMessageInfo

func (m *FileStarReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *FileStarReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *FileStarReq) GetFileIds() []string {
	if m != nil {
		return m.FileIds
	}
	return nil
}

///////////////////////////////////////////////////////////////////////
// 取消收藏文件（夹）
// "/box/file/unstar/1.0.0"
type FileUnstarReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	FileIds              []string `protobuf:"bytes,3,rep,name=fileIds,proto3" json:"fileIds"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileUnstarReq) Reset()         { *m = FileUnstarReq{} }
func (m *FileUnstarReq) String() string { return proto.CompactTextString(m) }
func (*FileUnstarReq) ProtoMessage()    {}
func (*FileUnstarReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{47}
}
func (m *FileUnstarReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileUnstarReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileUnstarReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileUnstarReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileUnstarReq.Merge(m, src)
}
func (m *FileUnstarReq) XXX_Size() int {
	return m.Size()
}
func (m *FileUnstarReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FileUnstarReq.DiscardUnknown(m)
}

var xxx_messageInfo_FileUnstarReq proto.InternalMessageInfo

func (m *FileUnstarReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *FileUnstarReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *FileUnstarReq) GetFileIds() []string {
	if m != nil {
		return m.FileIds
	}
	return nil
}

///////////////////////////////////////////////////////////////////////
// 回收站Item
type RecycleItem struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	FileId               string   `protobuf:"bytes,2,opt,name=fileId,proto3" json:"fileId"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name"`
	Size_                int64    `protobuf:"varint,4,opt,name=size,proto3" json:"size"`
	IsFolder             bool     `protobuf:"varint,5,opt,name=isFolder,proto3" json:"isFolder"`
	CreatedAt            int64    `protobuf:"varint,6,opt,name=createdAt,proto3" json:"createdAt"`
	Ext                  string   `protobuf:"bytes,7,opt,name=ext,proto3" json:"ext"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RecycleItem) Reset()         { *m = RecycleItem{} }
func (m *RecycleItem) String() string { return proto.CompactTextString(m) }
func (*RecycleItem) ProtoMessage()    {}
func (*RecycleItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{48}
}
func (m *RecycleItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecycleItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecycleItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecycleItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecycleItem.Merge(m, src)
}
func (m *RecycleItem) XXX_Size() int {
	return m.Size()
}
func (m *RecycleItem) XXX_DiscardUnknown() {
	xxx_messageInfo_RecycleItem.DiscardUnknown(m)
}

var xxx_messageInfo_RecycleItem proto.InternalMessageInfo

func (m *RecycleItem) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RecycleItem) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *RecycleItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RecycleItem) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *RecycleItem) GetIsFolder() bool {
	if m != nil {
		return m.IsFolder
	}
	return false
}

func (m *RecycleItem) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *RecycleItem) GetExt() string {
	if m != nil {
		return m.Ext
	}
	return ""
}

///////////////////////////////////////////////////////////////////////
// 回收站列表
// "/box/recycle/list/1.0.0"
type RecycleListReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	Order                int32    `protobuf:"varint,3,opt,name=order,proto3" json:"order"`
	Offset               int32    `protobuf:"varint,4,opt,name=offset,proto3" json:"offset"`
	Limit                int32    `protobuf:"varint,5,opt,name=limit,proto3" json:"limit"`
	Keyword              string   `protobuf:"bytes,7,opt,name=keyword,proto3" json:"keyword"`
	FileType             int32    `protobuf:"varint,8,opt,name=fileType,proto3" json:"fileType"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RecycleListReq) Reset()         { *m = RecycleListReq{} }
func (m *RecycleListReq) String() string { return proto.CompactTextString(m) }
func (*RecycleListReq) ProtoMessage()    {}
func (*RecycleListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{49}
}
func (m *RecycleListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecycleListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecycleListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecycleListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecycleListReq.Merge(m, src)
}
func (m *RecycleListReq) XXX_Size() int {
	return m.Size()
}
func (m *RecycleListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RecycleListReq.DiscardUnknown(m)
}

var xxx_messageInfo_RecycleListReq proto.InternalMessageInfo

func (m *RecycleListReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *RecycleListReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *RecycleListReq) GetOrder() int32 {
	if m != nil {
		return m.Order
	}
	return 0
}

func (m *RecycleListReq) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *RecycleListReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *RecycleListReq) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *RecycleListReq) GetFileType() int32 {
	if m != nil {
		return m.FileType
	}
	return 0
}

type RecycleListResp struct {
	Nonce                uint32         `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code           `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string         `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	Total                int32          `protobuf:"varint,4,opt,name=total,proto3" json:"total"`
	Items                []*RecycleItem `protobuf:"bytes,5,rep,name=items,proto3" json:"items"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *RecycleListResp) Reset()         { *m = RecycleListResp{} }
func (m *RecycleListResp) String() string { return proto.CompactTextString(m) }
func (*RecycleListResp) ProtoMessage()    {}
func (*RecycleListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{50}
}
func (m *RecycleListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecycleListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecycleListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecycleListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecycleListResp.Merge(m, src)
}
func (m *RecycleListResp) XXX_Size() int {
	return m.Size()
}
func (m *RecycleListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_RecycleListResp.DiscardUnknown(m)
}

var xxx_messageInfo_RecycleListResp proto.InternalMessageInfo

func (m *RecycleListResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *RecycleListResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *RecycleListResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *RecycleListResp) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *RecycleListResp) GetItems() []*RecycleItem {
	if m != nil {
		return m.Items
	}
	return nil
}

///////////////////////////////////////////////////////////////////////
// 回收站删除文件（夹）
// "/box/recycle/delete/1.0.0"
type RecycleDeleteReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	Ids                  []int32  `protobuf:"varint,3,rep,packed,name=ids,proto3" json:"ids"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RecycleDeleteReq) Reset()         { *m = RecycleDeleteReq{} }
func (m *RecycleDeleteReq) String() string { return proto.CompactTextString(m) }
func (*RecycleDeleteReq) ProtoMessage()    {}
func (*RecycleDeleteReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{51}
}
func (m *RecycleDeleteReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecycleDeleteReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecycleDeleteReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecycleDeleteReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecycleDeleteReq.Merge(m, src)
}
func (m *RecycleDeleteReq) XXX_Size() int {
	return m.Size()
}
func (m *RecycleDeleteReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RecycleDeleteReq.DiscardUnknown(m)
}

var xxx_messageInfo_RecycleDeleteReq proto.InternalMessageInfo

func (m *RecycleDeleteReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *RecycleDeleteReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *RecycleDeleteReq) GetIds() []int32 {
	if m != nil {
		return m.Ids
	}
	return nil
}

///////////////////////////////////////////////////////////////////////
// 回收站恢复删除文件（夹）
// "/box/recycle/restore/1.0.0"
type RecycleRestoreReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	Ids                  []int32  `protobuf:"varint,3,rep,packed,name=ids,proto3" json:"ids"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RecycleRestoreReq) Reset()         { *m = RecycleRestoreReq{} }
func (m *RecycleRestoreReq) String() string { return proto.CompactTextString(m) }
func (*RecycleRestoreReq) ProtoMessage()    {}
func (*RecycleRestoreReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{52}
}
func (m *RecycleRestoreReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecycleRestoreReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecycleRestoreReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecycleRestoreReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecycleRestoreReq.Merge(m, src)
}
func (m *RecycleRestoreReq) XXX_Size() int {
	return m.Size()
}
func (m *RecycleRestoreReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RecycleRestoreReq.DiscardUnknown(m)
}

var xxx_messageInfo_RecycleRestoreReq proto.InternalMessageInfo

func (m *RecycleRestoreReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *RecycleRestoreReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *RecycleRestoreReq) GetIds() []int32 {
	if m != nil {
		return m.Ids
	}
	return nil
}

///////////////////////////////////////////////////////////////////////
// 共享文件（夹）
// "/box/file/share/1.0.0"
type FileShareReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	FileIds              []string `protobuf:"bytes,3,rep,name=fileIds,proto3" json:"fileIds"`
	UserIdList           string   `protobuf:"bytes,4,opt,name=userIdList,proto3" json:"userIdList"`
	StartAt              int64    `protobuf:"varint,5,opt,name=startAt,proto3" json:"startAt"`
	EndAt                int64    `protobuf:"varint,6,opt,name=endAt,proto3" json:"endAt"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileShareReq) Reset()         { *m = FileShareReq{} }
func (m *FileShareReq) String() string { return proto.CompactTextString(m) }
func (*FileShareReq) ProtoMessage()    {}
func (*FileShareReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{53}
}
func (m *FileShareReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileShareReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileShareReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileShareReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileShareReq.Merge(m, src)
}
func (m *FileShareReq) XXX_Size() int {
	return m.Size()
}
func (m *FileShareReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FileShareReq.DiscardUnknown(m)
}

var xxx_messageInfo_FileShareReq proto.InternalMessageInfo

func (m *FileShareReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *FileShareReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *FileShareReq) GetFileIds() []string {
	if m != nil {
		return m.FileIds
	}
	return nil
}

func (m *FileShareReq) GetUserIdList() string {
	if m != nil {
		return m.UserIdList
	}
	return ""
}

func (m *FileShareReq) GetStartAt() int64 {
	if m != nil {
		return m.StartAt
	}
	return 0
}

func (m *FileShareReq) GetEndAt() int64 {
	if m != nil {
		return m.EndAt
	}
	return 0
}

///////////////////////////////////////////////////////////////////////
// 取消共享文件（夹）
// "/box/file/unshare/1.0.0"
type FileUnShareReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	FileIds              []string `protobuf:"bytes,3,rep,name=fileIds,proto3" json:"fileIds"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileUnShareReq) Reset()         { *m = FileUnShareReq{} }
func (m *FileUnShareReq) String() string { return proto.CompactTextString(m) }
func (*FileUnShareReq) ProtoMessage()    {}
func (*FileUnShareReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{54}
}
func (m *FileUnShareReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileUnShareReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileUnShareReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileUnShareReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileUnShareReq.Merge(m, src)
}
func (m *FileUnShareReq) XXX_Size() int {
	return m.Size()
}
func (m *FileUnShareReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FileUnShareReq.DiscardUnknown(m)
}

var xxx_messageInfo_FileUnShareReq proto.InternalMessageInfo

func (m *FileUnShareReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *FileUnShareReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *FileUnShareReq) GetFileIds() []string {
	if m != nil {
		return m.FileIds
	}
	return nil
}

// 关闭共享文件（夹）
// "/box/file/close_share/1.0.0"
type FileCloseShareReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	UserId               uint32   `protobuf:"varint,3,opt,name=userId,proto3" json:"userId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileCloseShareReq) Reset()         { *m = FileCloseShareReq{} }
func (m *FileCloseShareReq) String() string { return proto.CompactTextString(m) }
func (*FileCloseShareReq) ProtoMessage()    {}
func (*FileCloseShareReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{55}
}
func (m *FileCloseShareReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileCloseShareReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileCloseShareReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileCloseShareReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileCloseShareReq.Merge(m, src)
}
func (m *FileCloseShareReq) XXX_Size() int {
	return m.Size()
}
func (m *FileCloseShareReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FileCloseShareReq.DiscardUnknown(m)
}

var xxx_messageInfo_FileCloseShareReq proto.InternalMessageInfo

func (m *FileCloseShareReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *FileCloseShareReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *FileCloseShareReq) GetUserId() uint32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

///////////////////////////////////////////////////////////////////////
// 指定人员的共享文件（夹）列表
// "/box/file/sharelist/1.0.0"
type ShareListReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	UserId               uint32   `protobuf:"varint,3,opt,name=userId,proto3" json:"userId"`
	UserName             string   `protobuf:"bytes,4,opt,name=userName,proto3" json:"userName"`
	ParentId             string   `protobuf:"bytes,5,opt,name=parentId,proto3" json:"parentId"`
	DirMask              int32    `protobuf:"varint,6,opt,name=dirMask,proto3" json:"dirMask"`
	FileType             int32    `protobuf:"varint,7,opt,name=fileType,proto3" json:"fileType"`
	StarMask             int32    `protobuf:"varint,8,opt,name=starMask,proto3" json:"starMask"`
	Keyword              string   `protobuf:"bytes,9,opt,name=keyword,proto3" json:"keyword"`
	Order                int32    `protobuf:"varint,10,opt,name=order,proto3" json:"order"`
	Offset               int32    `protobuf:"varint,11,opt,name=offset,proto3" json:"offset"`
	Limit                int32    `protobuf:"varint,12,opt,name=limit,proto3" json:"limit"`
	Ext                  string   `protobuf:"bytes,13,opt,name=ext,proto3" json:"ext"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShareListReq) Reset()         { *m = ShareListReq{} }
func (m *ShareListReq) String() string { return proto.CompactTextString(m) }
func (*ShareListReq) ProtoMessage()    {}
func (*ShareListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{56}
}
func (m *ShareListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShareListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShareListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShareListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShareListReq.Merge(m, src)
}
func (m *ShareListReq) XXX_Size() int {
	return m.Size()
}
func (m *ShareListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ShareListReq.DiscardUnknown(m)
}

var xxx_messageInfo_ShareListReq proto.InternalMessageInfo

func (m *ShareListReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *ShareListReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *ShareListReq) GetUserId() uint32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ShareListReq) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *ShareListReq) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *ShareListReq) GetDirMask() int32 {
	if m != nil {
		return m.DirMask
	}
	return 0
}

func (m *ShareListReq) GetFileType() int32 {
	if m != nil {
		return m.FileType
	}
	return 0
}

func (m *ShareListReq) GetStarMask() int32 {
	if m != nil {
		return m.StarMask
	}
	return 0
}

func (m *ShareListReq) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *ShareListReq) GetOrder() int32 {
	if m != nil {
		return m.Order
	}
	return 0
}

func (m *ShareListReq) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *ShareListReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ShareListReq) GetExt() string {
	if m != nil {
		return m.Ext
	}
	return ""
}

///////////////////////////////////////////////////////////////////////
// 共享Item
type ShareItem struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	FileId               string   `protobuf:"bytes,2,opt,name=fileId,proto3" json:"fileId"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name"`
	Size_                int64    `protobuf:"varint,4,opt,name=size,proto3" json:"size"`
	IsFolder             bool     `protobuf:"varint,5,opt,name=isFolder,proto3" json:"isFolder"`
	FileType             string   `protobuf:"bytes,6,opt,name=fileType,proto3" json:"fileType"`
	CreatedAt            int64    `protobuf:"varint,7,opt,name=createdAt,proto3" json:"createdAt"`
	UserName             string   `protobuf:"bytes,8,opt,name=userName,proto3" json:"userName"`
	EndAt                int64    `protobuf:"varint,9,opt,name=endAt,proto3" json:"endAt"`
	CountPeople          int64    `protobuf:"varint,10,opt,name=countPeople,proto3" json:"countPeople"`
	Ext                  string   `protobuf:"bytes,11,opt,name=ext,proto3" json:"ext"`
	Share                bool     `protobuf:"varint,12,opt,name=share,proto3" json:"share"`
	Md5                  string   `protobuf:"bytes,13,opt,name=md5,proto3" json:"md5"`
	ParentId             string   `protobuf:"bytes,14,opt,name=parentId,proto3" json:"parentId"`
	SubFiles             int32    `protobuf:"varint,16,opt,name=subFiles,proto3" json:"subFiles"`
	Cid                  string   `protobuf:"bytes,17,opt,name=cid,proto3" json:"cid"`
	StartAt              int64    `protobuf:"varint,18,opt,name=startAt,proto3" json:"startAt"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShareItem) Reset()         { *m = ShareItem{} }
func (m *ShareItem) String() string { return proto.CompactTextString(m) }
func (*ShareItem) ProtoMessage()    {}
func (*ShareItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{57}
}
func (m *ShareItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShareItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShareItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShareItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShareItem.Merge(m, src)
}
func (m *ShareItem) XXX_Size() int {
	return m.Size()
}
func (m *ShareItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ShareItem.DiscardUnknown(m)
}

var xxx_messageInfo_ShareItem proto.InternalMessageInfo

func (m *ShareItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ShareItem) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *ShareItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ShareItem) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *ShareItem) GetIsFolder() bool {
	if m != nil {
		return m.IsFolder
	}
	return false
}

func (m *ShareItem) GetFileType() string {
	if m != nil {
		return m.FileType
	}
	return ""
}

func (m *ShareItem) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *ShareItem) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *ShareItem) GetEndAt() int64 {
	if m != nil {
		return m.EndAt
	}
	return 0
}

func (m *ShareItem) GetCountPeople() int64 {
	if m != nil {
		return m.CountPeople
	}
	return 0
}

func (m *ShareItem) GetExt() string {
	if m != nil {
		return m.Ext
	}
	return ""
}

func (m *ShareItem) GetShare() bool {
	if m != nil {
		return m.Share
	}
	return false
}

func (m *ShareItem) GetMd5() string {
	if m != nil {
		return m.Md5
	}
	return ""
}

func (m *ShareItem) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *ShareItem) GetSubFiles() int32 {
	if m != nil {
		return m.SubFiles
	}
	return 0
}

func (m *ShareItem) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

func (m *ShareItem) GetStartAt() int64 {
	if m != nil {
		return m.StartAt
	}
	return 0
}

type ShareListResp struct {
	Nonce                uint32       `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code         `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string       `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	Total                int32        `protobuf:"varint,4,opt,name=total,proto3" json:"total"`
	Items                []*ShareItem `protobuf:"bytes,5,rep,name=items,proto3" json:"items"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ShareListResp) Reset()         { *m = ShareListResp{} }
func (m *ShareListResp) String() string { return proto.CompactTextString(m) }
func (*ShareListResp) ProtoMessage()    {}
func (*ShareListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{58}
}
func (m *ShareListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShareListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShareListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShareListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShareListResp.Merge(m, src)
}
func (m *ShareListResp) XXX_Size() int {
	return m.Size()
}
func (m *ShareListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ShareListResp.DiscardUnknown(m)
}

var xxx_messageInfo_ShareListResp proto.InternalMessageInfo

func (m *ShareListResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *ShareListResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *ShareListResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ShareListResp) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *ShareListResp) GetItems() []*ShareItem {
	if m != nil {
		return m.Items
	}
	return nil
}

///////////////////////////////////////////////////////////////////////
// 统计用户共享文件（夹）
// "/box/file/usersharelist/1.0.0"
type UserShareListReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	Keyword              string   `protobuf:"bytes,3,opt,name=keyword,proto3" json:"keyword"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserShareListReq) Reset()         { *m = UserShareListReq{} }
func (m *UserShareListReq) String() string { return proto.CompactTextString(m) }
func (*UserShareListReq) ProtoMessage()    {}
func (*UserShareListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{59}
}
func (m *UserShareListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserShareListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserShareListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserShareListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserShareListReq.Merge(m, src)
}
func (m *UserShareListReq) XXX_Size() int {
	return m.Size()
}
func (m *UserShareListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UserShareListReq.DiscardUnknown(m)
}

var xxx_messageInfo_UserShareListReq proto.InternalMessageInfo

func (m *UserShareListReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *UserShareListReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *UserShareListReq) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

///////////////////////////////////////////////////////////////////////
// 用户共享Item
type UserShareItem struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	FileId               string   `protobuf:"bytes,2,opt,name=fileId,proto3" json:"fileId"`
	UserId               int32    `protobuf:"varint,3,opt,name=userId,proto3" json:"userId"`
	UserName             string   `protobuf:"bytes,4,opt,name=userName,proto3" json:"userName"`
	FolderCount          int64    `protobuf:"varint,5,opt,name=folderCount,proto3" json:"folderCount"`
	FileCount            int64    `protobuf:"varint,6,opt,name=fileCount,proto3" json:"fileCount"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserShareItem) Reset()         { *m = UserShareItem{} }
func (m *UserShareItem) String() string { return proto.CompactTextString(m) }
func (*UserShareItem) ProtoMessage()    {}
func (*UserShareItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{60}
}
func (m *UserShareItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserShareItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserShareItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserShareItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserShareItem.Merge(m, src)
}
func (m *UserShareItem) XXX_Size() int {
	return m.Size()
}
func (m *UserShareItem) XXX_DiscardUnknown() {
	xxx_messageInfo_UserShareItem.DiscardUnknown(m)
}

var xxx_messageInfo_UserShareItem proto.InternalMessageInfo

func (m *UserShareItem) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UserShareItem) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *UserShareItem) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserShareItem) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *UserShareItem) GetFolderCount() int64 {
	if m != nil {
		return m.FolderCount
	}
	return 0
}

func (m *UserShareItem) GetFileCount() int64 {
	if m != nil {
		return m.FileCount
	}
	return 0
}

type UserShareListResp struct {
	Nonce                uint32           `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code             `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string           `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	Total                int32            `protobuf:"varint,4,opt,name=total,proto3" json:"total"`
	Items                []*UserShareItem `protobuf:"bytes,5,rep,name=items,proto3" json:"items"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *UserShareListResp) Reset()         { *m = UserShareListResp{} }
func (m *UserShareListResp) String() string { return proto.CompactTextString(m) }
func (*UserShareListResp) ProtoMessage()    {}
func (*UserShareListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{61}
}
func (m *UserShareListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserShareListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserShareListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserShareListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserShareListResp.Merge(m, src)
}
func (m *UserShareListResp) XXX_Size() int {
	return m.Size()
}
func (m *UserShareListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_UserShareListResp.DiscardUnknown(m)
}

var xxx_messageInfo_UserShareListResp proto.InternalMessageInfo

func (m *UserShareListResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *UserShareListResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *UserShareListResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *UserShareListResp) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *UserShareListResp) GetItems() []*UserShareItem {
	if m != nil {
		return m.Items
	}
	return nil
}

///////////////////////////////////////////////////////////////////////
// 修改共享文件（夹）
// "/box/file/edit_share/1.0.0"
type FileEditShareReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	FileIds              []string `protobuf:"bytes,3,rep,name=fileIds,proto3" json:"fileIds"`
	UserIdList           string   `protobuf:"bytes,4,opt,name=userIdList,proto3" json:"userIdList"`
	StartAt              int64    `protobuf:"varint,5,opt,name=startAt,proto3" json:"startAt"`
	EndAt                int64    `protobuf:"varint,6,opt,name=endAt,proto3" json:"endAt"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileEditShareReq) Reset()         { *m = FileEditShareReq{} }
func (m *FileEditShareReq) String() string { return proto.CompactTextString(m) }
func (*FileEditShareReq) ProtoMessage()    {}
func (*FileEditShareReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{62}
}
func (m *FileEditShareReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileEditShareReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileEditShareReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileEditShareReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileEditShareReq.Merge(m, src)
}
func (m *FileEditShareReq) XXX_Size() int {
	return m.Size()
}
func (m *FileEditShareReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FileEditShareReq.DiscardUnknown(m)
}

var xxx_messageInfo_FileEditShareReq proto.InternalMessageInfo

func (m *FileEditShareReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *FileEditShareReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *FileEditShareReq) GetFileIds() []string {
	if m != nil {
		return m.FileIds
	}
	return nil
}

func (m *FileEditShareReq) GetUserIdList() string {
	if m != nil {
		return m.UserIdList
	}
	return ""
}

func (m *FileEditShareReq) GetStartAt() int64 {
	if m != nil {
		return m.StartAt
	}
	return 0
}

func (m *FileEditShareReq) GetEndAt() int64 {
	if m != nil {
		return m.EndAt
	}
	return 0
}

///////////////////////////////////////////////////////////////////////
// 备份通讯录
// "/box/addressbook/backup/1.0.0"
type AddressbookBackupReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	DeviceName           string   `protobuf:"bytes,3,opt,name=deviceName,proto3" json:"deviceName"`
	Content              string   `protobuf:"bytes,4,opt,name=content,proto3" json:"content"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddressbookBackupReq) Reset()         { *m = AddressbookBackupReq{} }
func (m *AddressbookBackupReq) String() string { return proto.CompactTextString(m) }
func (*AddressbookBackupReq) ProtoMessage()    {}
func (*AddressbookBackupReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{63}
}
func (m *AddressbookBackupReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressbookBackupReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddressbookBackupReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddressbookBackupReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressbookBackupReq.Merge(m, src)
}
func (m *AddressbookBackupReq) XXX_Size() int {
	return m.Size()
}
func (m *AddressbookBackupReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressbookBackupReq.DiscardUnknown(m)
}

var xxx_messageInfo_AddressbookBackupReq proto.InternalMessageInfo

func (m *AddressbookBackupReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *AddressbookBackupReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *AddressbookBackupReq) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *AddressbookBackupReq) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

///////////////////////////////////////////////////////////////////////
// 删除通讯录
// "/box/addressbook/delete/1.0.0"
type AddressbookDeleteReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	Id                   int32    `protobuf:"varint,3,opt,name=id,proto3" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddressbookDeleteReq) Reset()         { *m = AddressbookDeleteReq{} }
func (m *AddressbookDeleteReq) String() string { return proto.CompactTextString(m) }
func (*AddressbookDeleteReq) ProtoMessage()    {}
func (*AddressbookDeleteReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{64}
}
func (m *AddressbookDeleteReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressbookDeleteReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddressbookDeleteReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddressbookDeleteReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressbookDeleteReq.Merge(m, src)
}
func (m *AddressbookDeleteReq) XXX_Size() int {
	return m.Size()
}
func (m *AddressbookDeleteReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressbookDeleteReq.DiscardUnknown(m)
}

var xxx_messageInfo_AddressbookDeleteReq proto.InternalMessageInfo

func (m *AddressbookDeleteReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *AddressbookDeleteReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *AddressbookDeleteReq) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

///////////////////////////////////////////////////////////////////////
// 删除所有通讯录
// "/box/addressbook/delete_all/1.0.0"
type AddressbookDeleteAllReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddressbookDeleteAllReq) Reset()         { *m = AddressbookDeleteAllReq{} }
func (m *AddressbookDeleteAllReq) String() string { return proto.CompactTextString(m) }
func (*AddressbookDeleteAllReq) ProtoMessage()    {}
func (*AddressbookDeleteAllReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{65}
}
func (m *AddressbookDeleteAllReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressbookDeleteAllReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddressbookDeleteAllReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddressbookDeleteAllReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressbookDeleteAllReq.Merge(m, src)
}
func (m *AddressbookDeleteAllReq) XXX_Size() int {
	return m.Size()
}
func (m *AddressbookDeleteAllReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressbookDeleteAllReq.DiscardUnknown(m)
}

var xxx_messageInfo_AddressbookDeleteAllReq proto.InternalMessageInfo

func (m *AddressbookDeleteAllReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *AddressbookDeleteAllReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

///////////////////////////////////////////////////////////////////////
// 获取通讯录列表
// "/box/addressbook/list/1.0.0"
type AddressbookListReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	Offset               int32    `protobuf:"varint,3,opt,name=offset,proto3" json:"offset"`
	Limit                int32    `protobuf:"varint,4,opt,name=limit,proto3" json:"limit"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddressbookListReq) Reset()         { *m = AddressbookListReq{} }
func (m *AddressbookListReq) String() string { return proto.CompactTextString(m) }
func (*AddressbookListReq) ProtoMessage()    {}
func (*AddressbookListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{66}
}
func (m *AddressbookListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressbookListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddressbookListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddressbookListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressbookListReq.Merge(m, src)
}
func (m *AddressbookListReq) XXX_Size() int {
	return m.Size()
}
func (m *AddressbookListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressbookListReq.DiscardUnknown(m)
}

var xxx_messageInfo_AddressbookListReq proto.InternalMessageInfo

func (m *AddressbookListReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *AddressbookListReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *AddressbookListReq) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *AddressbookListReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type Addressbook struct {
	Id                   uint32   `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	BackupAt             uint64   `protobuf:"varint,2,opt,name=backupAt,proto3" json:"backupAt"`
	DeviceName           string   `protobuf:"bytes,3,opt,name=deviceName,proto3" json:"deviceName"`
	Content              string   `protobuf:"bytes,4,opt,name=content,proto3" json:"content"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Addressbook) Reset()         { *m = Addressbook{} }
func (m *Addressbook) String() string { return proto.CompactTextString(m) }
func (*Addressbook) ProtoMessage()    {}
func (*Addressbook) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{67}
}
func (m *Addressbook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Addressbook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Addressbook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Addressbook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Addressbook.Merge(m, src)
}
func (m *Addressbook) XXX_Size() int {
	return m.Size()
}
func (m *Addressbook) XXX_DiscardUnknown() {
	xxx_messageInfo_Addressbook.DiscardUnknown(m)
}

var xxx_messageInfo_Addressbook proto.InternalMessageInfo

func (m *Addressbook) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Addressbook) GetBackupAt() uint64 {
	if m != nil {
		return m.BackupAt
	}
	return 0
}

func (m *Addressbook) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *Addressbook) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

type AddressbookListResp struct {
	Nonce                uint32         `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code           `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string         `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	Total                int32          `protobuf:"varint,4,opt,name=total,proto3" json:"total"`
	Addressbooks         []*Addressbook `protobuf:"bytes,5,rep,name=addressbooks,proto3" json:"addressbooks"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *AddressbookListResp) Reset()         { *m = AddressbookListResp{} }
func (m *AddressbookListResp) String() string { return proto.CompactTextString(m) }
func (*AddressbookListResp) ProtoMessage()    {}
func (*AddressbookListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{68}
}
func (m *AddressbookListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddressbookListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddressbookListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddressbookListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressbookListResp.Merge(m, src)
}
func (m *AddressbookListResp) XXX_Size() int {
	return m.Size()
}
func (m *AddressbookListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressbookListResp.DiscardUnknown(m)
}

var xxx_messageInfo_AddressbookListResp proto.InternalMessageInfo

func (m *AddressbookListResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *AddressbookListResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *AddressbookListResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *AddressbookListResp) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *AddressbookListResp) GetAddressbooks() []*Addressbook {
	if m != nil {
		return m.Addressbooks
	}
	return nil
}

// 获取指定通讯录
// "/box/appoint_address/list/1.0.0"
type AppointAddressListReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	Id                   int32    `protobuf:"varint,3,opt,name=id,proto3" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppointAddressListReq) Reset()         { *m = AppointAddressListReq{} }
func (m *AppointAddressListReq) String() string { return proto.CompactTextString(m) }
func (*AppointAddressListReq) ProtoMessage()    {}
func (*AppointAddressListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{69}
}
func (m *AppointAddressListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppointAddressListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppointAddressListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppointAddressListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppointAddressListReq.Merge(m, src)
}
func (m *AppointAddressListReq) XXX_Size() int {
	return m.Size()
}
func (m *AppointAddressListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AppointAddressListReq.DiscardUnknown(m)
}

var xxx_messageInfo_AppointAddressListReq proto.InternalMessageInfo

func (m *AppointAddressListReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *AppointAddressListReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *AppointAddressListReq) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type AppointAddressListResp struct {
	Nonce                uint32         `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code           `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string         `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	Total                int32          `protobuf:"varint,4,opt,name=total,proto3" json:"total"`
	Addressbooks         []*Addressbook `protobuf:"bytes,5,rep,name=addressbooks,proto3" json:"addressbooks"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *AppointAddressListResp) Reset()         { *m = AppointAddressListResp{} }
func (m *AppointAddressListResp) String() string { return proto.CompactTextString(m) }
func (*AppointAddressListResp) ProtoMessage()    {}
func (*AppointAddressListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{70}
}
func (m *AppointAddressListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppointAddressListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppointAddressListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppointAddressListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppointAddressListResp.Merge(m, src)
}
func (m *AppointAddressListResp) XXX_Size() int {
	return m.Size()
}
func (m *AppointAddressListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_AppointAddressListResp.DiscardUnknown(m)
}

var xxx_messageInfo_AppointAddressListResp proto.InternalMessageInfo

func (m *AppointAddressListResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *AppointAddressListResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *AppointAddressListResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *AppointAddressListResp) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *AppointAddressListResp) GetAddressbooks() []*Addressbook {
	if m != nil {
		return m.Addressbooks
	}
	return nil
}

///////////////////////////////////////////////////////////////////////
// 获取指定文件夹下的数据
// "/box/file/appointlist/1.0.0"
type AppointFileListReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	ParentId             string   `protobuf:"bytes,3,opt,name=parentId,proto3" json:"parentId"`
	IsFolder             int32    `protobuf:"varint,4,opt,name=isFolder,proto3" json:"isFolder"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppointFileListReq) Reset()         { *m = AppointFileListReq{} }
func (m *AppointFileListReq) String() string { return proto.CompactTextString(m) }
func (*AppointFileListReq) ProtoMessage()    {}
func (*AppointFileListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{71}
}
func (m *AppointFileListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppointFileListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppointFileListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppointFileListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppointFileListReq.Merge(m, src)
}
func (m *AppointFileListReq) XXX_Size() int {
	return m.Size()
}
func (m *AppointFileListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AppointFileListReq.DiscardUnknown(m)
}

var xxx_messageInfo_AppointFileListReq proto.InternalMessageInfo

func (m *AppointFileListReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *AppointFileListReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *AppointFileListReq) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *AppointFileListReq) GetIsFolder() int32 {
	if m != nil {
		return m.IsFolder
	}
	return 0
}

type AppointFileListItem struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Uuid                 string   `protobuf:"bytes,2,opt,name=uuid,proto3" json:"uuid"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name"`
	Ext                  string   `protobuf:"bytes,4,opt,name=ext,proto3" json:"ext"`
	Size_                int64    `protobuf:"varint,5,opt,name=size,proto3" json:"size"`
	ParentId             string   `protobuf:"bytes,6,opt,name=parentId,proto3" json:"parentId"`
	IsFolder             bool     `protobuf:"varint,7,opt,name=isFolder,proto3" json:"isFolder"`
	Paths                string   `protobuf:"bytes,8,opt,name=paths,proto3" json:"paths"`
	Md5                  string   `protobuf:"bytes,9,opt,name=md5,proto3" json:"md5"`
	Children             string   `protobuf:"bytes,10,opt,name=children,proto3" json:"children"`
	Cid                  string   `protobuf:"bytes,11,opt,name=cid,proto3" json:"cid"`
	FilePaths            string   `protobuf:"bytes,12,opt,name=filePaths,proto3" json:"filePaths"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AppointFileListItem) Reset()         { *m = AppointFileListItem{} }
func (m *AppointFileListItem) String() string { return proto.CompactTextString(m) }
func (*AppointFileListItem) ProtoMessage()    {}
func (*AppointFileListItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{72}
}
func (m *AppointFileListItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppointFileListItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppointFileListItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppointFileListItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppointFileListItem.Merge(m, src)
}
func (m *AppointFileListItem) XXX_Size() int {
	return m.Size()
}
func (m *AppointFileListItem) XXX_DiscardUnknown() {
	xxx_messageInfo_AppointFileListItem.DiscardUnknown(m)
}

var xxx_messageInfo_AppointFileListItem proto.InternalMessageInfo

func (m *AppointFileListItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AppointFileListItem) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *AppointFileListItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AppointFileListItem) GetExt() string {
	if m != nil {
		return m.Ext
	}
	return ""
}

func (m *AppointFileListItem) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *AppointFileListItem) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *AppointFileListItem) GetIsFolder() bool {
	if m != nil {
		return m.IsFolder
	}
	return false
}

func (m *AppointFileListItem) GetPaths() string {
	if m != nil {
		return m.Paths
	}
	return ""
}

func (m *AppointFileListItem) GetMd5() string {
	if m != nil {
		return m.Md5
	}
	return ""
}

func (m *AppointFileListItem) GetChildren() string {
	if m != nil {
		return m.Children
	}
	return ""
}

func (m *AppointFileListItem) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

func (m *AppointFileListItem) GetFilePaths() string {
	if m != nil {
		return m.FilePaths
	}
	return ""
}

type AppointFileListResp struct {
	Nonce                uint32                 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code                   `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string                 `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	Total                int32                  `protobuf:"varint,4,opt,name=total,proto3" json:"total"`
	Items                []*AppointFileListItem `protobuf:"bytes,5,rep,name=items,proto3" json:"items"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *AppointFileListResp) Reset()         { *m = AppointFileListResp{} }
func (m *AppointFileListResp) String() string { return proto.CompactTextString(m) }
func (*AppointFileListResp) ProtoMessage()    {}
func (*AppointFileListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{73}
}
func (m *AppointFileListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppointFileListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppointFileListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppointFileListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppointFileListResp.Merge(m, src)
}
func (m *AppointFileListResp) XXX_Size() int {
	return m.Size()
}
func (m *AppointFileListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_AppointFileListResp.DiscardUnknown(m)
}

var xxx_messageInfo_AppointFileListResp proto.InternalMessageInfo

func (m *AppointFileListResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *AppointFileListResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *AppointFileListResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *AppointFileListResp) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *AppointFileListResp) GetItems() []*AppointFileListItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// 获取指定备份文件夹下的数据
// "/box/file/backup_list/1.0.0"
type FileBackupListReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	FormDevice           string   `protobuf:"bytes,3,opt,name=formDevice,proto3" json:"formDevice"`
	Offset               int32    `protobuf:"varint,4,opt,name=offset,proto3" json:"offset"`
	Limit                int32    `protobuf:"varint,5,opt,name=limit,proto3" json:"limit"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileBackupListReq) Reset()         { *m = FileBackupListReq{} }
func (m *FileBackupListReq) String() string { return proto.CompactTextString(m) }
func (*FileBackupListReq) ProtoMessage()    {}
func (*FileBackupListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{74}
}
func (m *FileBackupListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileBackupListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileBackupListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileBackupListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileBackupListReq.Merge(m, src)
}
func (m *FileBackupListReq) XXX_Size() int {
	return m.Size()
}
func (m *FileBackupListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FileBackupListReq.DiscardUnknown(m)
}

var xxx_messageInfo_FileBackupListReq proto.InternalMessageInfo

func (m *FileBackupListReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *FileBackupListReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *FileBackupListReq) GetFormDevice() string {
	if m != nil {
		return m.FormDevice
	}
	return ""
}

func (m *FileBackupListReq) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *FileBackupListReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type FileBackupListResp struct {
	Nonce                uint32                 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code                   `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string                 `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	Total                int32                  `protobuf:"varint,4,opt,name=total,proto3" json:"total"`
	Items                []*AppointFileListItem `protobuf:"bytes,5,rep,name=items,proto3" json:"items"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *FileBackupListResp) Reset()         { *m = FileBackupListResp{} }
func (m *FileBackupListResp) String() string { return proto.CompactTextString(m) }
func (*FileBackupListResp) ProtoMessage()    {}
func (*FileBackupListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{75}
}
func (m *FileBackupListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileBackupListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileBackupListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileBackupListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileBackupListResp.Merge(m, src)
}
func (m *FileBackupListResp) XXX_Size() int {
	return m.Size()
}
func (m *FileBackupListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_FileBackupListResp.DiscardUnknown(m)
}

var xxx_messageInfo_FileBackupListResp proto.InternalMessageInfo

func (m *FileBackupListResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *FileBackupListResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *FileBackupListResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *FileBackupListResp) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *FileBackupListResp) GetItems() []*AppointFileListItem {
	if m != nil {
		return m.Items
	}
	return nil
}

///////////////////////////////////////////////////////////////////////
// 查询文件md5是否存在
// "/box/file/searchmd5/1.0.0"
type SearchFileMd5Req struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	Md5                  string   `protobuf:"bytes,3,opt,name=md5,proto3" json:"md5"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SearchFileMd5Req) Reset()         { *m = SearchFileMd5Req{} }
func (m *SearchFileMd5Req) String() string { return proto.CompactTextString(m) }
func (*SearchFileMd5Req) ProtoMessage()    {}
func (*SearchFileMd5Req) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{76}
}
func (m *SearchFileMd5Req) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchFileMd5Req) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchFileMd5Req.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchFileMd5Req) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchFileMd5Req.Merge(m, src)
}
func (m *SearchFileMd5Req) XXX_Size() int {
	return m.Size()
}
func (m *SearchFileMd5Req) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchFileMd5Req.DiscardUnknown(m)
}

var xxx_messageInfo_SearchFileMd5Req proto.InternalMessageInfo

func (m *SearchFileMd5Req) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *SearchFileMd5Req) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *SearchFileMd5Req) GetMd5() string {
	if m != nil {
		return m.Md5
	}
	return ""
}

type SearchFileMd5Resp struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code     `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Id                   string   `protobuf:"bytes,3,opt,name=id,proto3" json:"id"`
	Cid                  string   `protobuf:"bytes,4,opt,name=cid,proto3" json:"cid"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SearchFileMd5Resp) Reset()         { *m = SearchFileMd5Resp{} }
func (m *SearchFileMd5Resp) String() string { return proto.CompactTextString(m) }
func (*SearchFileMd5Resp) ProtoMessage()    {}
func (*SearchFileMd5Resp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{77}
}
func (m *SearchFileMd5Resp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchFileMd5Resp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchFileMd5Resp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchFileMd5Resp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchFileMd5Resp.Merge(m, src)
}
func (m *SearchFileMd5Resp) XXX_Size() int {
	return m.Size()
}
func (m *SearchFileMd5Resp) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchFileMd5Resp.DiscardUnknown(m)
}

var xxx_messageInfo_SearchFileMd5Resp proto.InternalMessageInfo

func (m *SearchFileMd5Resp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *SearchFileMd5Resp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *SearchFileMd5Resp) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SearchFileMd5Resp) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

//CommonResp
//  添加文件（夹）记录
// "/box/file/file_record/1.0.0"
type FileRecordReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	FileId               string   `protobuf:"bytes,3,opt,name=fileId,proto3" json:"fileId"`
	ParentId             string   `protobuf:"bytes,4,opt,name=parentId,proto3" json:"parentId"`
	Name                 string   `protobuf:"bytes,5,opt,name=name,proto3" json:"name"`
	Cid                  string   `protobuf:"bytes,6,opt,name=cid,proto3" json:"cid"`
	Md5                  string   `protobuf:"bytes,7,opt,name=md5,proto3" json:"md5"`
	IsFolder             int32    `protobuf:"varint,8,opt,name=isFolder,proto3" json:"isFolder"`
	Size_                int64    `protobuf:"varint,9,opt,name=size,proto3" json:"size"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileRecordReq) Reset()         { *m = FileRecordReq{} }
func (m *FileRecordReq) String() string { return proto.CompactTextString(m) }
func (*FileRecordReq) ProtoMessage()    {}
func (*FileRecordReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{78}
}
func (m *FileRecordReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileRecordReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileRecordReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileRecordReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileRecordReq.Merge(m, src)
}
func (m *FileRecordReq) XXX_Size() int {
	return m.Size()
}
func (m *FileRecordReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FileRecordReq.DiscardUnknown(m)
}

var xxx_messageInfo_FileRecordReq proto.InternalMessageInfo

func (m *FileRecordReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *FileRecordReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *FileRecordReq) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *FileRecordReq) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *FileRecordReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FileRecordReq) GetCid() string {
	if m != nil {
		return m.Cid
	}
	return ""
}

func (m *FileRecordReq) GetMd5() string {
	if m != nil {
		return m.Md5
	}
	return ""
}

func (m *FileRecordReq) GetIsFolder() int32 {
	if m != nil {
		return m.IsFolder
	}
	return 0
}

func (m *FileRecordReq) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

///////////////////////////////////////////////////////////////////////
// 备份记录
// "/box/backups/list/1.0.0"
type BackupsListReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	Offset               int32    `protobuf:"varint,3,opt,name=offset,proto3" json:"offset"`
	Limit                int32    `protobuf:"varint,4,opt,name=limit,proto3" json:"limit"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BackupsListReq) Reset()         { *m = BackupsListReq{} }
func (m *BackupsListReq) String() string { return proto.CompactTextString(m) }
func (*BackupsListReq) ProtoMessage()    {}
func (*BackupsListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{79}
}
func (m *BackupsListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupsListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupsListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupsListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupsListReq.Merge(m, src)
}
func (m *BackupsListReq) XXX_Size() int {
	return m.Size()
}
func (m *BackupsListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupsListReq.DiscardUnknown(m)
}

var xxx_messageInfo_BackupsListReq proto.InternalMessageInfo

func (m *BackupsListReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *BackupsListReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *BackupsListReq) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *BackupsListReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type BackupsListItem struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	DeviceName           string   `protobuf:"bytes,2,opt,name=deviceName,proto3" json:"deviceName"`
	FileCount            int32    `protobuf:"varint,3,opt,name=fileCount,proto3" json:"fileCount"`
	CreatedAt            int64    `protobuf:"varint,4,opt,name=createdAt,proto3" json:"createdAt"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BackupsListItem) Reset()         { *m = BackupsListItem{} }
func (m *BackupsListItem) String() string { return proto.CompactTextString(m) }
func (*BackupsListItem) ProtoMessage()    {}
func (*BackupsListItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{80}
}
func (m *BackupsListItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupsListItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupsListItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupsListItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupsListItem.Merge(m, src)
}
func (m *BackupsListItem) XXX_Size() int {
	return m.Size()
}
func (m *BackupsListItem) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupsListItem.DiscardUnknown(m)
}

var xxx_messageInfo_BackupsListItem proto.InternalMessageInfo

func (m *BackupsListItem) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BackupsListItem) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *BackupsListItem) GetFileCount() int32 {
	if m != nil {
		return m.FileCount
	}
	return 0
}

func (m *BackupsListItem) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

type BackupsListResp struct {
	Nonce                uint32             `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code               `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string             `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	Total                int32              `protobuf:"varint,4,opt,name=total,proto3" json:"total"`
	Items                []*BackupsListItem `protobuf:"bytes,5,rep,name=items,proto3" json:"items"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *BackupsListResp) Reset()         { *m = BackupsListResp{} }
func (m *BackupsListResp) String() string { return proto.CompactTextString(m) }
func (*BackupsListResp) ProtoMessage()    {}
func (*BackupsListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{81}
}
func (m *BackupsListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupsListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupsListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupsListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupsListResp.Merge(m, src)
}
func (m *BackupsListResp) XXX_Size() int {
	return m.Size()
}
func (m *BackupsListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupsListResp.DiscardUnknown(m)
}

var xxx_messageInfo_BackupsListResp proto.InternalMessageInfo

func (m *BackupsListResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *BackupsListResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *BackupsListResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *BackupsListResp) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *BackupsListResp) GetItems() []*BackupsListItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// 添加备份记录
// "/box/backups/add/1.0.0"
type BackupsAddReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	DeviceName           string   `protobuf:"bytes,3,opt,name=deviceName,proto3" json:"deviceName"`
	FileCount            int32    `protobuf:"varint,4,opt,name=fileCount,proto3" json:"fileCount"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BackupsAddReq) Reset()         { *m = BackupsAddReq{} }
func (m *BackupsAddReq) String() string { return proto.CompactTextString(m) }
func (*BackupsAddReq) ProtoMessage()    {}
func (*BackupsAddReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{82}
}
func (m *BackupsAddReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupsAddReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupsAddReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupsAddReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupsAddReq.Merge(m, src)
}
func (m *BackupsAddReq) XXX_Size() int {
	return m.Size()
}
func (m *BackupsAddReq) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupsAddReq.DiscardUnknown(m)
}

var xxx_messageInfo_BackupsAddReq proto.InternalMessageInfo

func (m *BackupsAddReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *BackupsAddReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *BackupsAddReq) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *BackupsAddReq) GetFileCount() int32 {
	if m != nil {
		return m.FileCount
	}
	return 0
}

///////////////////////////////////////////////////////////////////////
// 日志
// "/box/log/list/1.0.0"
type FileLogListReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	Status               int32    `protobuf:"varint,3,opt,name=status,proto3" json:"status"`
	SearchTime           int32    `protobuf:"varint,4,opt,name=searchTime,proto3" json:"searchTime"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileLogListReq) Reset()         { *m = FileLogListReq{} }
func (m *FileLogListReq) String() string { return proto.CompactTextString(m) }
func (*FileLogListReq) ProtoMessage()    {}
func (*FileLogListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{83}
}
func (m *FileLogListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileLogListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileLogListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileLogListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileLogListReq.Merge(m, src)
}
func (m *FileLogListReq) XXX_Size() int {
	return m.Size()
}
func (m *FileLogListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_FileLogListReq.DiscardUnknown(m)
}

var xxx_messageInfo_FileLogListReq proto.InternalMessageInfo

func (m *FileLogListReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *FileLogListReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *FileLogListReq) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *FileLogListReq) GetSearchTime() int32 {
	if m != nil {
		return m.SearchTime
	}
	return 0
}

type FileLogListResp struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code     `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string   `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	Id                   int32    `protobuf:"varint,4,opt,name=id,proto3" json:"id"`
	FileId               string   `protobuf:"bytes,5,opt,name=fileId,proto3" json:"fileId"`
	Status               int32    `protobuf:"varint,6,opt,name=status,proto3" json:"status"`
	IdList               string   `protobuf:"bytes,7,opt,name=idList,proto3" json:"idList"`
	CreatedAt            int64    `protobuf:"varint,8,opt,name=createdAt,proto3" json:"createdAt"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileLogListResp) Reset()         { *m = FileLogListResp{} }
func (m *FileLogListResp) String() string { return proto.CompactTextString(m) }
func (*FileLogListResp) ProtoMessage()    {}
func (*FileLogListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{84}
}
func (m *FileLogListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileLogListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileLogListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileLogListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileLogListResp.Merge(m, src)
}
func (m *FileLogListResp) XXX_Size() int {
	return m.Size()
}
func (m *FileLogListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_FileLogListResp.DiscardUnknown(m)
}

var xxx_messageInfo_FileLogListResp proto.InternalMessageInfo

func (m *FileLogListResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *FileLogListResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *FileLogListResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *FileLogListResp) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *FileLogListResp) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *FileLogListResp) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *FileLogListResp) GetIdList() string {
	if m != nil {
		return m.IdList
	}
	return ""
}

func (m *FileLogListResp) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

///////////////////////////////////////////////////////////////////////
// 同步设置
// "/box/sync/list/1.0.0"
type SyncListReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	DeviceName           string   `protobuf:"bytes,3,opt,name=deviceName,proto3" json:"deviceName"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SyncListReq) Reset()         { *m = SyncListReq{} }
func (m *SyncListReq) String() string { return proto.CompactTextString(m) }
func (*SyncListReq) ProtoMessage()    {}
func (*SyncListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{85}
}
func (m *SyncListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncListReq.Merge(m, src)
}
func (m *SyncListReq) XXX_Size() int {
	return m.Size()
}
func (m *SyncListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncListReq.DiscardUnknown(m)
}

var xxx_messageInfo_SyncListReq proto.InternalMessageInfo

func (m *SyncListReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *SyncListReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *SyncListReq) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

type SyncListItem struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	DeviceName           string   `protobuf:"bytes,2,opt,name=deviceName,proto3" json:"deviceName"`
	DevicePath           string   `protobuf:"bytes,3,opt,name=devicePath,proto3" json:"devicePath"`
	FileId               string   `protobuf:"bytes,4,opt,name=fileId,proto3" json:"fileId"`
	Status               int32    `protobuf:"varint,5,opt,name=status,proto3" json:"status"`
	CreatedAt            int64    `protobuf:"varint,6,opt,name=createdAt,proto3" json:"createdAt"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SyncListItem) Reset()         { *m = SyncListItem{} }
func (m *SyncListItem) String() string { return proto.CompactTextString(m) }
func (*SyncListItem) ProtoMessage()    {}
func (*SyncListItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{86}
}
func (m *SyncListItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncListItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncListItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncListItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncListItem.Merge(m, src)
}
func (m *SyncListItem) XXX_Size() int {
	return m.Size()
}
func (m *SyncListItem) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncListItem.DiscardUnknown(m)
}

var xxx_messageInfo_SyncListItem proto.InternalMessageInfo

func (m *SyncListItem) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SyncListItem) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *SyncListItem) GetDevicePath() string {
	if m != nil {
		return m.DevicePath
	}
	return ""
}

func (m *SyncListItem) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *SyncListItem) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *SyncListItem) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

type SyncListResp struct {
	Nonce                uint32          `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code            `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string          `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	Total                int32           `protobuf:"varint,4,opt,name=total,proto3" json:"total"`
	Items                []*SyncListItem `protobuf:"bytes,5,rep,name=items,proto3" json:"items"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SyncListResp) Reset()         { *m = SyncListResp{} }
func (m *SyncListResp) String() string { return proto.CompactTextString(m) }
func (*SyncListResp) ProtoMessage()    {}
func (*SyncListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{87}
}
func (m *SyncListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncListResp.Merge(m, src)
}
func (m *SyncListResp) XXX_Size() int {
	return m.Size()
}
func (m *SyncListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncListResp.DiscardUnknown(m)
}

var xxx_messageInfo_SyncListResp proto.InternalMessageInfo

func (m *SyncListResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *SyncListResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *SyncListResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *SyncListResp) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *SyncListResp) GetItems() []*SyncListItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// 添加同步设置
// "/box/sync/add/1.0.0"
type SyncAddReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	DeviceName           string   `protobuf:"bytes,3,opt,name=deviceName,proto3" json:"deviceName"`
	DevicePath           string   `protobuf:"bytes,4,opt,name=devicePath,proto3" json:"devicePath"`
	FileId               string   `protobuf:"bytes,5,opt,name=fileId,proto3" json:"fileId"`
	Status               int32    `protobuf:"varint,6,opt,name=status,proto3" json:"status"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SyncAddReq) Reset()         { *m = SyncAddReq{} }
func (m *SyncAddReq) String() string { return proto.CompactTextString(m) }
func (*SyncAddReq) ProtoMessage()    {}
func (*SyncAddReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{88}
}
func (m *SyncAddReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncAddReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncAddReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncAddReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncAddReq.Merge(m, src)
}
func (m *SyncAddReq) XXX_Size() int {
	return m.Size()
}
func (m *SyncAddReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncAddReq.DiscardUnknown(m)
}

var xxx_messageInfo_SyncAddReq proto.InternalMessageInfo

func (m *SyncAddReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *SyncAddReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *SyncAddReq) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *SyncAddReq) GetDevicePath() string {
	if m != nil {
		return m.DevicePath
	}
	return ""
}

func (m *SyncAddReq) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *SyncAddReq) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

// 修改同步设置
// "/box/sync/edit/1.0.0"
type SyncEditReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	Id                   int32    `protobuf:"varint,3,opt,name=id,proto3" json:"id"`
	DeviceName           string   `protobuf:"bytes,4,opt,name=deviceName,proto3" json:"deviceName"`
	DevicePath           string   `protobuf:"bytes,5,opt,name=devicePath,proto3" json:"devicePath"`
	FileId               string   `protobuf:"bytes,6,opt,name=fileId,proto3" json:"fileId"`
	Status               int32    `protobuf:"varint,7,opt,name=status,proto3" json:"status"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SyncEditReq) Reset()         { *m = SyncEditReq{} }
func (m *SyncEditReq) String() string { return proto.CompactTextString(m) }
func (*SyncEditReq) ProtoMessage()    {}
func (*SyncEditReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{89}
}
func (m *SyncEditReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncEditReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncEditReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncEditReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncEditReq.Merge(m, src)
}
func (m *SyncEditReq) XXX_Size() int {
	return m.Size()
}
func (m *SyncEditReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncEditReq.DiscardUnknown(m)
}

var xxx_messageInfo_SyncEditReq proto.InternalMessageInfo

func (m *SyncEditReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *SyncEditReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *SyncEditReq) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SyncEditReq) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *SyncEditReq) GetDevicePath() string {
	if m != nil {
		return m.DevicePath
	}
	return ""
}

func (m *SyncEditReq) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *SyncEditReq) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

//CommonResp
// 删除同步设置
// "/box/sync/del/1.0.0"
type SyncDelReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	Id                   int32    `protobuf:"varint,3,opt,name=id,proto3" json:"id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SyncDelReq) Reset()         { *m = SyncDelReq{} }
func (m *SyncDelReq) String() string { return proto.CompactTextString(m) }
func (*SyncDelReq) ProtoMessage()    {}
func (*SyncDelReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{90}
}
func (m *SyncDelReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncDelReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncDelReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncDelReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncDelReq.Merge(m, src)
}
func (m *SyncDelReq) XXX_Size() int {
	return m.Size()
}
func (m *SyncDelReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncDelReq.DiscardUnknown(m)
}

var xxx_messageInfo_SyncDelReq proto.InternalMessageInfo

func (m *SyncDelReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *SyncDelReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *SyncDelReq) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

// box升级
// "/box/update/1.0.0"
type BoxUpdateReq struct {
	Token                string   `protobuf:"bytes,1,opt,name=token,proto3" json:"token"`
	Md5                  string   `protobuf:"bytes,2,opt,name=md5,proto3" json:"md5"`
	Version              string   `protobuf:"bytes,3,opt,name=version,proto3" json:"version"`
	Url                  string   `protobuf:"bytes,4,opt,name=url,proto3" json:"url"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BoxUpdateReq) Reset()         { *m = BoxUpdateReq{} }
func (m *BoxUpdateReq) String() string { return proto.CompactTextString(m) }
func (*BoxUpdateReq) ProtoMessage()    {}
func (*BoxUpdateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{91}
}
func (m *BoxUpdateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BoxUpdateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BoxUpdateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BoxUpdateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BoxUpdateReq.Merge(m, src)
}
func (m *BoxUpdateReq) XXX_Size() int {
	return m.Size()
}
func (m *BoxUpdateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_BoxUpdateReq.DiscardUnknown(m)
}

var xxx_messageInfo_BoxUpdateReq proto.InternalMessageInfo

func (m *BoxUpdateReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *BoxUpdateReq) GetMd5() string {
	if m != nil {
		return m.Md5
	}
	return ""
}

func (m *BoxUpdateReq) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *BoxUpdateReq) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

type BoxUpdateResp struct {
	Code                 Code     `protobuf:"varint,1,opt,name=code,proto3,enum=Code" json:"code"`
	Status               int32    `protobuf:"varint,2,opt,name=status,proto3" json:"status"`
	Msg                  string   `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BoxUpdateResp) Reset()         { *m = BoxUpdateResp{} }
func (m *BoxUpdateResp) String() string { return proto.CompactTextString(m) }
func (*BoxUpdateResp) ProtoMessage()    {}
func (*BoxUpdateResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{92}
}
func (m *BoxUpdateResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BoxUpdateResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BoxUpdateResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BoxUpdateResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BoxUpdateResp.Merge(m, src)
}
func (m *BoxUpdateResp) XXX_Size() int {
	return m.Size()
}
func (m *BoxUpdateResp) XXX_DiscardUnknown() {
	xxx_messageInfo_BoxUpdateResp.DiscardUnknown(m)
}

var xxx_messageInfo_BoxUpdateResp proto.InternalMessageInfo

func (m *BoxUpdateResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *BoxUpdateResp) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *BoxUpdateResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// 获取box参数
// "/box/deviceInfo/1.0.0"
type DeviceInfoReq struct {
	Token                string   `protobuf:"bytes,1,opt,name=token,proto3" json:"token"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeviceInfoReq) Reset()         { *m = DeviceInfoReq{} }
func (m *DeviceInfoReq) String() string { return proto.CompactTextString(m) }
func (*DeviceInfoReq) ProtoMessage()    {}
func (*DeviceInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{93}
}
func (m *DeviceInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceInfoReq.Merge(m, src)
}
func (m *DeviceInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *DeviceInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceInfoReq proto.InternalMessageInfo

func (m *DeviceInfoReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type DeviceInfoResp struct {
	Code                 Code     `protobuf:"varint,1,opt,name=code,proto3,enum=Code" json:"code"`
	Version              string   `protobuf:"bytes,2,opt,name=version,proto3" json:"version"`
	Sn                   string   `protobuf:"bytes,3,opt,name=sn,proto3" json:"sn"`
	Framework            string   `protobuf:"bytes,4,opt,name=framework,proto3" json:"framework"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeviceInfoResp) Reset()         { *m = DeviceInfoResp{} }
func (m *DeviceInfoResp) String() string { return proto.CompactTextString(m) }
func (*DeviceInfoResp) ProtoMessage()    {}
func (*DeviceInfoResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{94}
}
func (m *DeviceInfoResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceInfoResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceInfoResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceInfoResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceInfoResp.Merge(m, src)
}
func (m *DeviceInfoResp) XXX_Size() int {
	return m.Size()
}
func (m *DeviceInfoResp) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceInfoResp.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceInfoResp proto.InternalMessageInfo

func (m *DeviceInfoResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *DeviceInfoResp) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *DeviceInfoResp) GetSn() string {
	if m != nil {
		return m.Sn
	}
	return ""
}

func (m *DeviceInfoResp) GetFramework() string {
	if m != nil {
		return m.Framework
	}
	return ""
}

// 获取磁盘空间
// "/box/diskCount/1.0.0"
type DiskCountReq struct {
	PeerId               string   `protobuf:"bytes,1,opt,name=peerId,proto3" json:"peerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiskCountReq) Reset()         { *m = DiskCountReq{} }
func (m *DiskCountReq) String() string { return proto.CompactTextString(m) }
func (*DiskCountReq) ProtoMessage()    {}
func (*DiskCountReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{95}
}
func (m *DiskCountReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiskCountReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiskCountReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiskCountReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiskCountReq.Merge(m, src)
}
func (m *DiskCountReq) XXX_Size() int {
	return m.Size()
}
func (m *DiskCountReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DiskCountReq.DiscardUnknown(m)
}

var xxx_messageInfo_DiskCountReq proto.InternalMessageInfo

func (m *DiskCountReq) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

type DiskCountResp struct {
	Code                 Code     `protobuf:"varint,1,opt,name=code,proto3,enum=Code" json:"code"`
	DeviceCount          uint64   `protobuf:"varint,2,opt,name=deviceCount,proto3" json:"deviceCount"`
	DeviceUsed           uint64   `protobuf:"varint,3,opt,name=deviceUsed,proto3" json:"deviceUsed"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiskCountResp) Reset()         { *m = DiskCountResp{} }
func (m *DiskCountResp) String() string { return proto.CompactTextString(m) }
func (*DiskCountResp) ProtoMessage()    {}
func (*DiskCountResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{96}
}
func (m *DiskCountResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiskCountResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiskCountResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiskCountResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiskCountResp.Merge(m, src)
}
func (m *DiskCountResp) XXX_Size() int {
	return m.Size()
}
func (m *DiskCountResp) XXX_DiscardUnknown() {
	xxx_messageInfo_DiskCountResp.DiscardUnknown(m)
}

var xxx_messageInfo_DiskCountResp proto.InternalMessageInfo

func (m *DiskCountResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *DiskCountResp) GetDeviceCount() uint64 {
	if m != nil {
		return m.DeviceCount
	}
	return 0
}

func (m *DiskCountResp) GetDeviceUsed() uint64 {
	if m != nil {
		return m.DeviceUsed
	}
	return 0
}

// 创建钱包地址 0 所有钱包，1 Fil钱包，2 ETH系列钱包
// "/box/createWallet/1.0.0"
type CreateWalletReq struct {
	Type                 int32    `protobuf:"varint,1,opt,name=type,proto3" json:"type"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateWalletReq) Reset()         { *m = CreateWalletReq{} }
func (m *CreateWalletReq) String() string { return proto.CompactTextString(m) }
func (*CreateWalletReq) ProtoMessage()    {}
func (*CreateWalletReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{97}
}
func (m *CreateWalletReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateWalletReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateWalletReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateWalletReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateWalletReq.Merge(m, src)
}
func (m *CreateWalletReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateWalletReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateWalletReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateWalletReq proto.InternalMessageInfo

func (m *CreateWalletReq) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CreateWalletReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

// 获取钱包地址 0 所有钱包，1 Fil钱包，2 ETH系列钱包
// "/box/getWallet/1.0.0"
type GetWalletReq struct {
	Type                 int32    `protobuf:"varint,1,opt,name=type,proto3" json:"type"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetWalletReq) Reset()         { *m = GetWalletReq{} }
func (m *GetWalletReq) String() string { return proto.CompactTextString(m) }
func (*GetWalletReq) ProtoMessage()    {}
func (*GetWalletReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{98}
}
func (m *GetWalletReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWalletReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWalletReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWalletReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWalletReq.Merge(m, src)
}
func (m *GetWalletReq) XXX_Size() int {
	return m.Size()
}
func (m *GetWalletReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWalletReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetWalletReq proto.InternalMessageInfo

func (m *GetWalletReq) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *GetWalletReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type WalletItem struct {
	Type                 int32    `protobuf:"varint,1,opt,name=type,proto3" json:"type"`
	Address              string   `protobuf:"bytes,2,opt,name=address,proto3" json:"address"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WalletItem) Reset()         { *m = WalletItem{} }
func (m *WalletItem) String() string { return proto.CompactTextString(m) }
func (*WalletItem) ProtoMessage()    {}
func (*WalletItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{99}
}
func (m *WalletItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WalletItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WalletItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WalletItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WalletItem.Merge(m, src)
}
func (m *WalletItem) XXX_Size() int {
	return m.Size()
}
func (m *WalletItem) XXX_DiscardUnknown() {
	xxx_messageInfo_WalletItem.DiscardUnknown(m)
}

var xxx_messageInfo_WalletItem proto.InternalMessageInfo

func (m *WalletItem) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *WalletItem) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type GetWalletResp struct {
	Code                 Code          `protobuf:"varint,1,opt,name=code,proto3,enum=Code" json:"code"`
	Items                []*WalletItem `protobuf:"bytes,2,rep,name=items,proto3" json:"items"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *GetWalletResp) Reset()         { *m = GetWalletResp{} }
func (m *GetWalletResp) String() string { return proto.CompactTextString(m) }
func (*GetWalletResp) ProtoMessage()    {}
func (*GetWalletResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{100}
}
func (m *GetWalletResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWalletResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWalletResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWalletResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWalletResp.Merge(m, src)
}
func (m *GetWalletResp) XXX_Size() int {
	return m.Size()
}
func (m *GetWalletResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWalletResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetWalletResp proto.InternalMessageInfo

func (m *GetWalletResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *GetWalletResp) GetItems() []*WalletItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// 获取钱包地址的key 0 所有钱包，1 Fil钱包，2 ETH系列钱包
// "/box/getWalletKey/1.0.0"
type GetWalletKeyReq struct {
	Token                string   `protobuf:"bytes,1,opt,name=token,proto3" json:"token"`
	Address              string   `protobuf:"bytes,2,opt,name=address,proto3" json:"address"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetWalletKeyReq) Reset()         { *m = GetWalletKeyReq{} }
func (m *GetWalletKeyReq) String() string { return proto.CompactTextString(m) }
func (*GetWalletKeyReq) ProtoMessage()    {}
func (*GetWalletKeyReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{101}
}
func (m *GetWalletKeyReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWalletKeyReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWalletKeyReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWalletKeyReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWalletKeyReq.Merge(m, src)
}
func (m *GetWalletKeyReq) XXX_Size() int {
	return m.Size()
}
func (m *GetWalletKeyReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWalletKeyReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetWalletKeyReq proto.InternalMessageInfo

func (m *GetWalletKeyReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *GetWalletKeyReq) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type GetWalletKeyResp struct {
	Code                 Code     `protobuf:"varint,1,opt,name=code,proto3,enum=Code" json:"code"`
	AddressKey           string   `protobuf:"bytes,2,opt,name=addressKey,proto3" json:"addressKey"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetWalletKeyResp) Reset()         { *m = GetWalletKeyResp{} }
func (m *GetWalletKeyResp) String() string { return proto.CompactTextString(m) }
func (*GetWalletKeyResp) ProtoMessage()    {}
func (*GetWalletKeyResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{102}
}
func (m *GetWalletKeyResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetWalletKeyResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetWalletKeyResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetWalletKeyResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWalletKeyResp.Merge(m, src)
}
func (m *GetWalletKeyResp) XXX_Size() int {
	return m.Size()
}
func (m *GetWalletKeyResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWalletKeyResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetWalletKeyResp proto.InternalMessageInfo

func (m *GetWalletKeyResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *GetWalletKeyResp) GetAddressKey() string {
	if m != nil {
		return m.AddressKey
	}
	return ""
}

///////////////////////////////////////////////////////////////////////
// 同步数据到FileCoin
// "/box/sync_fil/1.0.0"
type EnableFilReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	Enable               bool     `protobuf:"varint,3,opt,name=enable,proto3" json:"enable"`
	RelayHost            string   `protobuf:"bytes,4,opt,name=relayHost,proto3" json:"relayHost"`
	MinerId              string   `protobuf:"bytes,5,opt,name=minerId,proto3" json:"minerId"`
	Price                string   `protobuf:"bytes,6,opt,name=price,proto3" json:"price"`
	SizeSum              int64    `protobuf:"varint,7,opt,name=sizeSum,proto3" json:"sizeSum"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnableFilReq) Reset()         { *m = EnableFilReq{} }
func (m *EnableFilReq) String() string { return proto.CompactTextString(m) }
func (*EnableFilReq) ProtoMessage()    {}
func (*EnableFilReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{103}
}
func (m *EnableFilReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnableFilReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnableFilReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnableFilReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnableFilReq.Merge(m, src)
}
func (m *EnableFilReq) XXX_Size() int {
	return m.Size()
}
func (m *EnableFilReq) XXX_DiscardUnknown() {
	xxx_messageInfo_EnableFilReq.DiscardUnknown(m)
}

var xxx_messageInfo_EnableFilReq proto.InternalMessageInfo

func (m *EnableFilReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *EnableFilReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *EnableFilReq) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *EnableFilReq) GetRelayHost() string {
	if m != nil {
		return m.RelayHost
	}
	return ""
}

func (m *EnableFilReq) GetMinerId() string {
	if m != nil {
		return m.MinerId
	}
	return ""
}

func (m *EnableFilReq) GetPrice() string {
	if m != nil {
		return m.Price
	}
	return ""
}

func (m *EnableFilReq) GetSizeSum() int64 {
	if m != nil {
		return m.SizeSum
	}
	return 0
}

//============= Filecoin backup
//备份文件
// "/lotus/filecoinBackup"
type UploadFileToFilcoinReq struct {
	IpfsCid              string   `protobuf:"bytes,1,opt,name=ipfsCid,proto3" json:"ipfsCid"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data"`
	FileSize             int64    `protobuf:"varint,3,opt,name=fileSize,proto3" json:"fileSize"`
	BytesFrom            int64    `protobuf:"varint,4,opt,name=bytes_from,json=bytesFrom,proto3" json:"bytes_from"`
	PeerId               string   `protobuf:"bytes,5,opt,name=peerId,proto3" json:"peerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadFileToFilcoinReq) Reset()         { *m = UploadFileToFilcoinReq{} }
func (m *UploadFileToFilcoinReq) String() string { return proto.CompactTextString(m) }
func (*UploadFileToFilcoinReq) ProtoMessage()    {}
func (*UploadFileToFilcoinReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{104}
}
func (m *UploadFileToFilcoinReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadFileToFilcoinReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadFileToFilcoinReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadFileToFilcoinReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadFileToFilcoinReq.Merge(m, src)
}
func (m *UploadFileToFilcoinReq) XXX_Size() int {
	return m.Size()
}
func (m *UploadFileToFilcoinReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadFileToFilcoinReq.DiscardUnknown(m)
}

var xxx_messageInfo_UploadFileToFilcoinReq proto.InternalMessageInfo

func (m *UploadFileToFilcoinReq) GetIpfsCid() string {
	if m != nil {
		return m.IpfsCid
	}
	return ""
}

func (m *UploadFileToFilcoinReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *UploadFileToFilcoinReq) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *UploadFileToFilcoinReq) GetBytesFrom() int64 {
	if m != nil {
		return m.BytesFrom
	}
	return 0
}

func (m *UploadFileToFilcoinReq) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

//查询备份状态
// "/lotus/getBackUpStatus"
type GetBackUpStatusReq struct {
	IpfsCid              string   `protobuf:"bytes,1,opt,name=ipfsCid,proto3" json:"ipfsCid"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBackUpStatusReq) Reset()         { *m = GetBackUpStatusReq{} }
func (m *GetBackUpStatusReq) String() string { return proto.CompactTextString(m) }
func (*GetBackUpStatusReq) ProtoMessage()    {}
func (*GetBackUpStatusReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{105}
}
func (m *GetBackUpStatusReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBackUpStatusReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBackUpStatusReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBackUpStatusReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBackUpStatusReq.Merge(m, src)
}
func (m *GetBackUpStatusReq) XXX_Size() int {
	return m.Size()
}
func (m *GetBackUpStatusReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBackUpStatusReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetBackUpStatusReq proto.InternalMessageInfo

func (m *GetBackUpStatusReq) GetIpfsCid() string {
	if m != nil {
		return m.IpfsCid
	}
	return ""
}

type GetBackUpStatusResp struct {
	Code                 Code     `protobuf:"varint,1,opt,name=code,proto3,enum=Code" json:"code"`
	DealCid              string   `protobuf:"bytes,2,opt,name=dealCid,proto3" json:"dealCid"`
	PieceCid             string   `protobuf:"bytes,3,opt,name=pieceCid,proto3" json:"pieceCid"`
	Status               string   `protobuf:"bytes,4,opt,name=status,proto3" json:"status"`
	Verified             bool     `protobuf:"varint,5,opt,name=Verified,proto3" json:"Verified"`
	Duration             uint64   `protobuf:"varint,6,opt,name=Duration,proto3" json:"Duration"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetBackUpStatusResp) Reset()         { *m = GetBackUpStatusResp{} }
func (m *GetBackUpStatusResp) String() string { return proto.CompactTextString(m) }
func (*GetBackUpStatusResp) ProtoMessage()    {}
func (*GetBackUpStatusResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{106}
}
func (m *GetBackUpStatusResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetBackUpStatusResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetBackUpStatusResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetBackUpStatusResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBackUpStatusResp.Merge(m, src)
}
func (m *GetBackUpStatusResp) XXX_Size() int {
	return m.Size()
}
func (m *GetBackUpStatusResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBackUpStatusResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetBackUpStatusResp proto.InternalMessageInfo

func (m *GetBackUpStatusResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *GetBackUpStatusResp) GetDealCid() string {
	if m != nil {
		return m.DealCid
	}
	return ""
}

func (m *GetBackUpStatusResp) GetPieceCid() string {
	if m != nil {
		return m.PieceCid
	}
	return ""
}

func (m *GetBackUpStatusResp) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *GetBackUpStatusResp) GetVerified() bool {
	if m != nil {
		return m.Verified
	}
	return false
}

func (m *GetBackUpStatusResp) GetDuration() uint64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

// 获取miner
// "/api/getMiner"
type GetMinerReq struct {
	PeerId               string   `protobuf:"bytes,1,opt,name=peerId,proto3" json:"peerId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetMinerReq) Reset()         { *m = GetMinerReq{} }
func (m *GetMinerReq) String() string { return proto.CompactTextString(m) }
func (*GetMinerReq) ProtoMessage()    {}
func (*GetMinerReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{107}
}
func (m *GetMinerReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMinerReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMinerReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMinerReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMinerReq.Merge(m, src)
}
func (m *GetMinerReq) XXX_Size() int {
	return m.Size()
}
func (m *GetMinerReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMinerReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetMinerReq proto.InternalMessageInfo

func (m *GetMinerReq) GetPeerId() string {
	if m != nil {
		return m.PeerId
	}
	return ""
}

type GetMinerResp struct {
	Code                 Code     `protobuf:"varint,1,opt,name=code,proto3,enum=Code" json:"code"`
	Miner                []*Miner `protobuf:"bytes,2,rep,name=miner,proto3" json:"miner"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetMinerResp) Reset()         { *m = GetMinerResp{} }
func (m *GetMinerResp) String() string { return proto.CompactTextString(m) }
func (*GetMinerResp) ProtoMessage()    {}
func (*GetMinerResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{108}
}
func (m *GetMinerResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMinerResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMinerResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMinerResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMinerResp.Merge(m, src)
}
func (m *GetMinerResp) XXX_Size() int {
	return m.Size()
}
func (m *GetMinerResp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMinerResp.DiscardUnknown(m)
}

var xxx_messageInfo_GetMinerResp proto.InternalMessageInfo

func (m *GetMinerResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *GetMinerResp) GetMiner() []*Miner {
	if m != nil {
		return m.Miner
	}
	return nil
}

type Miner struct {
	MinerId              string   `protobuf:"bytes,1,opt,name=MinerId,proto3" json:"MinerId"`
	Storage              string   `protobuf:"bytes,2,opt,name=Storage,proto3" json:"Storage"`
	Price                string   `protobuf:"bytes,3,opt,name=Price,proto3" json:"Price"`
	RelayHost            string   `protobuf:"bytes,4,opt,name=RelayHost,proto3" json:"RelayHost"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Miner) Reset()         { *m = Miner{} }
func (m *Miner) String() string { return proto.CompactTextString(m) }
func (*Miner) ProtoMessage()    {}
func (*Miner) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{109}
}
func (m *Miner) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Miner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Miner.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Miner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Miner.Merge(m, src)
}
func (m *Miner) XXX_Size() int {
	return m.Size()
}
func (m *Miner) XXX_DiscardUnknown() {
	xxx_messageInfo_Miner.DiscardUnknown(m)
}

var xxx_messageInfo_Miner proto.InternalMessageInfo

func (m *Miner) GetMinerId() string {
	if m != nil {
		return m.MinerId
	}
	return ""
}

func (m *Miner) GetStorage() string {
	if m != nil {
		return m.Storage
	}
	return ""
}

func (m *Miner) GetPrice() string {
	if m != nil {
		return m.Price
	}
	return ""
}

func (m *Miner) GetRelayHost() string {
	if m != nil {
		return m.RelayHost
	}
	return ""
}

///////////////////////////////////////////////////////////////////////
// 备份记录
// "/box/cidbackups/list/1.0.0"
type CidBackupsListReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	Offset               int32    `protobuf:"varint,3,opt,name=offset,proto3" json:"offset"`
	Limit                int32    `protobuf:"varint,4,opt,name=limit,proto3" json:"limit"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CidBackupsListReq) Reset()         { *m = CidBackupsListReq{} }
func (m *CidBackupsListReq) String() string { return proto.CompactTextString(m) }
func (*CidBackupsListReq) ProtoMessage()    {}
func (*CidBackupsListReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{110}
}
func (m *CidBackupsListReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CidBackupsListReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CidBackupsListReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CidBackupsListReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CidBackupsListReq.Merge(m, src)
}
func (m *CidBackupsListReq) XXX_Size() int {
	return m.Size()
}
func (m *CidBackupsListReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CidBackupsListReq.DiscardUnknown(m)
}

var xxx_messageInfo_CidBackupsListReq proto.InternalMessageInfo

func (m *CidBackupsListReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *CidBackupsListReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *CidBackupsListReq) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *CidBackupsListReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type CidBackupsListItem struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	MinerId              string   `protobuf:"bytes,2,opt,name=minerId,proto3" json:"minerId"`
	Price                string   `protobuf:"bytes,3,opt,name=price,proto3" json:"price"`
	CreatedAt            int64    `protobuf:"varint,4,opt,name=createdAt,proto3" json:"createdAt"`
	FileCount            int64    `protobuf:"varint,5,opt,name=fileCount,proto3" json:"fileCount"`
	SuccessFile          int64    `protobuf:"varint,6,opt,name=successFile,proto3" json:"successFile"`
	DealCid              string   `protobuf:"bytes,7,opt,name=dealCid,proto3" json:"dealCid"`
	FileSize             int64    `protobuf:"varint,8,opt,name=fileSize,proto3" json:"fileSize"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CidBackupsListItem) Reset()         { *m = CidBackupsListItem{} }
func (m *CidBackupsListItem) String() string { return proto.CompactTextString(m) }
func (*CidBackupsListItem) ProtoMessage()    {}
func (*CidBackupsListItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{111}
}
func (m *CidBackupsListItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CidBackupsListItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CidBackupsListItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CidBackupsListItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CidBackupsListItem.Merge(m, src)
}
func (m *CidBackupsListItem) XXX_Size() int {
	return m.Size()
}
func (m *CidBackupsListItem) XXX_DiscardUnknown() {
	xxx_messageInfo_CidBackupsListItem.DiscardUnknown(m)
}

var xxx_messageInfo_CidBackupsListItem proto.InternalMessageInfo

func (m *CidBackupsListItem) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *CidBackupsListItem) GetMinerId() string {
	if m != nil {
		return m.MinerId
	}
	return ""
}

func (m *CidBackupsListItem) GetPrice() string {
	if m != nil {
		return m.Price
	}
	return ""
}

func (m *CidBackupsListItem) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *CidBackupsListItem) GetFileCount() int64 {
	if m != nil {
		return m.FileCount
	}
	return 0
}

func (m *CidBackupsListItem) GetSuccessFile() int64 {
	if m != nil {
		return m.SuccessFile
	}
	return 0
}

func (m *CidBackupsListItem) GetDealCid() string {
	if m != nil {
		return m.DealCid
	}
	return ""
}

func (m *CidBackupsListItem) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

type CidBackupsListResp struct {
	Nonce                uint32                `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code                  `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string                `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	Total                int32                 `protobuf:"varint,4,opt,name=total,proto3" json:"total"`
	Items                []*CidBackupsListItem `protobuf:"bytes,5,rep,name=items,proto3" json:"items"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *CidBackupsListResp) Reset()         { *m = CidBackupsListResp{} }
func (m *CidBackupsListResp) String() string { return proto.CompactTextString(m) }
func (*CidBackupsListResp) ProtoMessage()    {}
func (*CidBackupsListResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{112}
}
func (m *CidBackupsListResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CidBackupsListResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CidBackupsListResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CidBackupsListResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CidBackupsListResp.Merge(m, src)
}
func (m *CidBackupsListResp) XXX_Size() int {
	return m.Size()
}
func (m *CidBackupsListResp) XXX_DiscardUnknown() {
	xxx_messageInfo_CidBackupsListResp.DiscardUnknown(m)
}

var xxx_messageInfo_CidBackupsListResp proto.InternalMessageInfo

func (m *CidBackupsListResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *CidBackupsListResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *CidBackupsListResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *CidBackupsListResp) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *CidBackupsListResp) GetItems() []*CidBackupsListItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// 备份记录
// "/box/backupcount/list/1.0.0"
type BackupCountReq struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Token                string   `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BackupCountReq) Reset()         { *m = BackupCountReq{} }
func (m *BackupCountReq) String() string { return proto.CompactTextString(m) }
func (*BackupCountReq) ProtoMessage()    {}
func (*BackupCountReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{113}
}
func (m *BackupCountReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupCountReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupCountReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupCountReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupCountReq.Merge(m, src)
}
func (m *BackupCountReq) XXX_Size() int {
	return m.Size()
}
func (m *BackupCountReq) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupCountReq.DiscardUnknown(m)
}

var xxx_messageInfo_BackupCountReq proto.InternalMessageInfo

func (m *BackupCountReq) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *BackupCountReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type BackupCountResp struct {
	Nonce                uint32   `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce"`
	Code                 Code     `protobuf:"varint,2,opt,name=code,proto3,enum=Code" json:"code"`
	Msg                  string   `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg"`
	Total                int32    `protobuf:"varint,4,opt,name=total,proto3" json:"total"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BackupCountResp) Reset()         { *m = BackupCountResp{} }
func (m *BackupCountResp) String() string { return proto.CompactTextString(m) }
func (*BackupCountResp) ProtoMessage()    {}
func (*BackupCountResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_39028a0b6d2453b4, []int{114}
}
func (m *BackupCountResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackupCountResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackupCountResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackupCountResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackupCountResp.Merge(m, src)
}
func (m *BackupCountResp) XXX_Size() int {
	return m.Size()
}
func (m *BackupCountResp) XXX_DiscardUnknown() {
	xxx_messageInfo_BackupCountResp.DiscardUnknown(m)
}

var xxx_messageInfo_BackupCountResp proto.InternalMessageInfo

func (m *BackupCountResp) GetNonce() uint32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *BackupCountResp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *BackupCountResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *BackupCountResp) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func init() {
	proto.RegisterEnum("Code", Code_name, Code_value)
	proto.RegisterType((*RelayReq)(nil), "RelayReq")
	proto.RegisterType((*RelayResp)(nil), "RelayResp")
	proto.RegisterType((*CommonResp)(nil), "CommonResp")
	proto.RegisterType((*PingReq)(nil), "PingReq")
	proto.RegisterType((*PingResp)(nil), "PingResp")
	proto.RegisterType((*PeerAddressReq)(nil), "PeerAddressReq")
	proto.RegisterType((*PeerAddressResp)(nil), "PeerAddressResp")
	proto.RegisterType((*User)(nil), "User")
	proto.RegisterType((*DiskSpace)(nil), "DiskSpace")
	proto.RegisterType((*DeviceStateReq)(nil), "DeviceStateReq")
	proto.RegisterType((*DeviceStateResp)(nil), "DeviceStateResp")
	proto.RegisterType((*ActivateReq)(nil), "ActivateReq")
	proto.RegisterType((*ActivateResp)(nil), "ActivateResp")
	proto.RegisterType((*ForgetPassReq)(nil), "ForgetPassReq")
	proto.RegisterType((*ForgetPassResp)(nil), "ForgetPassResp")
	proto.RegisterType((*LoginReq)(nil), "LoginReq")
	proto.RegisterType((*LoginResp)(nil), "LoginResp")
	proto.RegisterType((*AddUserReq)(nil), "AddUserReq")
	proto.RegisterType((*UserInfoReq)(nil), "UserInfoReq")
	proto.RegisterType((*UserInfoResp)(nil), "UserInfoResp")
	proto.RegisterType((*UserListReq)(nil), "UserListReq")
	proto.RegisterType((*UserListResp)(nil), "UserListResp")
	proto.RegisterType((*UpdatePasswordReq)(nil), "UpdatePasswordReq")
	proto.RegisterType((*UserRenameReq)(nil), "UserRenameReq")
	proto.RegisterType((*GetUserAvatarReq)(nil), "GetUserAvatarReq")
	proto.RegisterType((*GetUserAvatarResp)(nil), "GetUserAvatarResp")
	proto.RegisterType((*UpdateUserAvatarReq)(nil), "UpdateUserAvatarReq")
	proto.RegisterType((*ResetPasswordReq)(nil), "ResetPasswordReq")
	proto.RegisterType((*EnableUserReq)(nil), "EnableUserReq")
	proto.RegisterType((*DeleteUserReq)(nil), "DeleteUserReq")
	proto.RegisterType((*ChangeSpaceReq)(nil), "ChangeSpaceReq")
	proto.RegisterType((*ScanQrcodeReq)(nil), "ScanQrcodeReq")
	proto.RegisterType((*GetTokenByQrcodeReq)(nil), "GetTokenByQrcodeReq")
	proto.RegisterType((*GetTokenByQrcodeResp)(nil), "GetTokenByQrcodeResp")
	proto.RegisterType((*FileItem)(nil), "FileItem")
	proto.RegisterType((*NewFolderReq)(nil), "NewFolderReq")
	proto.RegisterType((*NewFolderResp)(nil), "NewFolderResp")
	proto.RegisterType((*UploadFileReq)(nil), "UploadFileReq")
	proto.RegisterType((*DownloadFileReq)(nil), "DownloadFileReq")
	proto.RegisterType((*DownloadFileResp)(nil), "DownloadFileResp")
	proto.RegisterType((*FileListReq)(nil), "FileListReq")
	proto.RegisterType((*FileListResp)(nil), "FileListResp")
	proto.RegisterType((*FileRenameReq)(nil), "FileRenameReq")
	proto.RegisterType((*FileDeleteReq)(nil), "FileDeleteReq")
	proto.RegisterType((*FileMoveReq)(nil), "FileMoveReq")
	proto.RegisterType((*FileCopyReq)(nil), "FileCopyReq")
	proto.RegisterType((*FileStarReq)(nil), "FileStarReq")
	proto.RegisterType((*FileUnstarReq)(nil), "FileUnstarReq")
	proto.RegisterType((*RecycleItem)(nil), "RecycleItem")
	proto.RegisterType((*RecycleListReq)(nil), "RecycleListReq")
	proto.RegisterType((*RecycleListResp)(nil), "RecycleListResp")
	proto.RegisterType((*RecycleDeleteReq)(nil), "RecycleDeleteReq")
	proto.RegisterType((*RecycleRestoreReq)(nil), "RecycleRestoreReq")
	proto.RegisterType((*FileShareReq)(nil), "FileShareReq")
	proto.RegisterType((*FileUnShareReq)(nil), "FileUnShareReq")
	proto.RegisterType((*FileCloseShareReq)(nil), "FileCloseShareReq")
	proto.RegisterType((*ShareListReq)(nil), "ShareListReq")
	proto.RegisterType((*ShareItem)(nil), "ShareItem")
	proto.RegisterType((*ShareListResp)(nil), "ShareListResp")
	proto.RegisterType((*UserShareListReq)(nil), "UserShareListReq")
	proto.RegisterType((*UserShareItem)(nil), "UserShareItem")
	proto.RegisterType((*UserShareListResp)(nil), "UserShareListResp")
	proto.RegisterType((*FileEditShareReq)(nil), "FileEditShareReq")
	proto.RegisterType((*AddressbookBackupReq)(nil), "AddressbookBackupReq")
	proto.RegisterType((*AddressbookDeleteReq)(nil), "AddressbookDeleteReq")
	proto.RegisterType((*AddressbookDeleteAllReq)(nil), "AddressbookDeleteAllReq")
	proto.RegisterType((*AddressbookListReq)(nil), "AddressbookListReq")
	proto.RegisterType((*Addressbook)(nil), "Addressbook")
	proto.RegisterType((*AddressbookListResp)(nil), "AddressbookListResp")
	proto.RegisterType((*AppointAddressListReq)(nil), "AppointAddressListReq")
	proto.RegisterType((*AppointAddressListResp)(nil), "AppointAddressListResp")
	proto.RegisterType((*AppointFileListReq)(nil), "AppointFileListReq")
	proto.RegisterType((*AppointFileListItem)(nil), "AppointFileListItem")
	proto.RegisterType((*AppointFileListResp)(nil), "AppointFileListResp")
	proto.RegisterType((*FileBackupListReq)(nil), "FileBackupListReq")
	proto.RegisterType((*FileBackupListResp)(nil), "FileBackupListResp")
	proto.RegisterType((*SearchFileMd5Req)(nil), "SearchFileMd5Req")
	proto.RegisterType((*SearchFileMd5Resp)(nil), "SearchFileMd5Resp")
	proto.RegisterType((*FileRecordReq)(nil), "FileRecordReq")
	proto.RegisterType((*BackupsListReq)(nil), "BackupsListReq")
	proto.RegisterType((*BackupsListItem)(nil), "BackupsListItem")
	proto.RegisterType((*BackupsListResp)(nil), "BackupsListResp")
	proto.RegisterType((*BackupsAddReq)(nil), "BackupsAddReq")
	proto.RegisterType((*FileLogListReq)(nil), "FileLogListReq")
	proto.RegisterType((*FileLogListResp)(nil), "FileLogListResp")
	proto.RegisterType((*SyncListReq)(nil), "SyncListReq")
	proto.RegisterType((*SyncListItem)(nil), "SyncListItem")
	proto.RegisterType((*SyncListResp)(nil), "SyncListResp")
	proto.RegisterType((*SyncAddReq)(nil), "SyncAddReq")
	proto.RegisterType((*SyncEditReq)(nil), "SyncEditReq")
	proto.RegisterType((*SyncDelReq)(nil), "SyncDelReq")
	proto.RegisterType((*BoxUpdateReq)(nil), "BoxUpdateReq")
	proto.RegisterType((*BoxUpdateResp)(nil), "BoxUpdateResp")
	proto.RegisterType((*DeviceInfoReq)(nil), "DeviceInfoReq")
	proto.RegisterType((*DeviceInfoResp)(nil), "DeviceInfoResp")
	proto.RegisterType((*DiskCountReq)(nil), "DiskCountReq")
	proto.RegisterType((*DiskCountResp)(nil), "DiskCountResp")
	proto.RegisterType((*CreateWalletReq)(nil), "CreateWalletReq")
	proto.RegisterType((*GetWalletReq)(nil), "GetWalletReq")
	proto.RegisterType((*WalletItem)(nil), "WalletItem")
	proto.RegisterType((*GetWalletResp)(nil), "GetWalletResp")
	proto.RegisterType((*GetWalletKeyReq)(nil), "GetWalletKeyReq")
	proto.RegisterType((*GetWalletKeyResp)(nil), "GetWalletKeyResp")
	proto.RegisterType((*EnableFilReq)(nil), "EnableFilReq")
	proto.RegisterType((*UploadFileToFilcoinReq)(nil), "UploadFileToFilcoinReq")
	proto.RegisterType((*GetBackUpStatusReq)(nil), "GetBackUpStatusReq")
	proto.RegisterType((*GetBackUpStatusResp)(nil), "GetBackUpStatusResp")
	proto.RegisterType((*GetMinerReq)(nil), "GetMinerReq")
	proto.RegisterType((*GetMinerResp)(nil), "GetMinerResp")
	proto.RegisterType((*Miner)(nil), "Miner")
	proto.RegisterType((*CidBackupsListReq)(nil), "CidBackupsListReq")
	proto.RegisterType((*CidBackupsListItem)(nil), "CidBackupsListItem")
	proto.RegisterType((*CidBackupsListResp)(nil), "CidBackupsListResp")
	proto.RegisterType((*BackupCountReq)(nil), "BackupCountReq")
	proto.RegisterType((*BackupCountResp)(nil), "BackupCountResp")
}

func init() { proto.RegisterFile("box.proto", fileDescriptor_39028a0b6d2453b4) }

var fileDescriptor_39028a0b6d2453b4 = []byte{
	// 3446 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x3b, 0x4b, 0x8f, 0xe4, 0x56,
	0xd5, 0x71, 0xb9, 0x5c, 0x8f, 0x53, 0x8f, 0xae, 0x76, 0x77, 0xe6, 0xab, 0x8c, 0xf2, 0x4d, 0x3a,
	0x17, 0x12, 0x0d, 0x59, 0x94, 0x50, 0x50, 0x24, 0x5e, 0x42, 0xea, 0xe9, 0x9e, 0x9e, 0x34, 0xc9,
	0x4c, 0x3a, 0xae, 0xe9, 0x04, 0xd8, 0x44, 0xee, 0xf2, 0xad, 0x1e, 0xa7, 0x5d, 0x76, 0x8d, 0xed,
	0xea, 0xe9, 0x8a, 0x80, 0x0d, 0x0b, 0x50, 0x14, 0x22, 0xc4, 0x2a, 0x61, 0x13, 0xa4, 0xb0, 0x00,
	0x01, 0xdb, 0x48, 0xf0, 0x07, 0x40, 0xc0, 0x82, 0x05, 0x12, 0x5b, 0x14, 0x36, 0xac, 0xf9, 0x03,
	0xa0, 0x73, 0x1f, 0xf6, 0xb5, 0xeb, 0x31, 0xb4, 0xa7, 0x2a, 0xc9, 0xae, 0xce, 0xb1, 0xef, 0x79,
	0xdd, 0xf3, 0xbc, 0xbe, 0x05, 0xf5, 0x93, 0xe0, 0xa2, 0x37, 0x0e, 0x83, 0x38, 0x20, 0xdf, 0x84,
	0x9a, 0x45, 0x3d, 0x7b, 0x6a, 0xd1, 0xfb, 0xe6, 0x35, 0x80, 0x23, 0x44, 0x0e, 0x02, 0xef, 0xd0,
	0xe9, 0x6a, 0x3b, 0xda, 0xf5, 0xba, 0xa5, 0x60, 0xf0, 0xf9, 0x8d, 0xc0, 0x99, 0xde, 0x98, 0x0c,
	0x87, 0x34, 0xec, 0x96, 0x76, 0xb4, 0xeb, 0x4d, 0x4b, 0xc1, 0x90, 0x37, 0xa0, 0x2e, 0x68, 0x45,
	0xe3, 0x47, 0x25, 0x66, 0x9a, 0x50, 0x1e, 0x04, 0x0e, 0xed, 0xea, 0x3b, 0xda, 0xf5, 0x96, 0xc5,
	0x7e, 0x93, 0x57, 0x00, 0xf6, 0x82, 0xd1, 0x28, 0xf0, 0x19, 0x87, 0x6d, 0x30, 0xfc, 0xc0, 0x1f,
	0x50, 0x46, 0xbc, 0x65, 0x71, 0xc0, 0x7c, 0x42, 0xac, 0x43, 0x8a, 0xed, 0xe7, 0x8d, 0xde, 0x5e,
	0xe0, 0x50, 0xbe, 0xdc, 0xec, 0x80, 0x3e, 0x8a, 0x4e, 0x19, 0xc5, 0xba, 0x85, 0x3f, 0xc9, 0x53,
	0x50, 0x3d, 0x72, 0xfd, 0x53, 0x54, 0x7e, 0x2e, 0x35, 0xb2, 0x03, 0x35, 0xfe, 0xc2, 0x22, 0x7e,
	0xe4, 0x1b, 0xd0, 0x3e, 0xa2, 0x34, 0xdc, 0x75, 0x9c, 0x90, 0x46, 0xd1, 0x42, 0x4a, 0xe6, 0x15,
	0xa8, 0x8c, 0x29, 0x0d, 0x0f, 0x1d, 0x26, 0x59, 0xdd, 0x12, 0x10, 0x39, 0x87, 0x8d, 0xcc, 0xfa,
	0x22, 0x8a, 0xed, 0x40, 0x63, 0x9c, 0xd2, 0xe8, 0xea, 0x3b, 0xfa, 0xf5, 0xba, 0xa5, 0xa2, 0xa4,
	0xea, 0xe5, 0x54, 0xf5, 0x9f, 0x94, 0xa0, 0x7c, 0x1c, 0xd1, 0xd0, 0x6c, 0x43, 0xc9, 0x75, 0x04,
	0xab, 0x92, 0xeb, 0xa0, 0xe1, 0x7d, 0x7b, 0x44, 0x85, 0x98, 0xec, 0x37, 0xe2, 0xc2, 0xc0, 0xe3,
	0x9b, 0x61, 0x58, 0xec, 0xb7, 0xf9, 0x2c, 0xb4, 0x6d, 0xcf, 0x0b, 0x06, 0x76, 0x4c, 0x9d, 0xfe,
	0xd8, 0x1e, 0x50, 0x46, 0xbd, 0x6c, 0xe5, 0xb0, 0xe6, 0x93, 0x50, 0x9f, 0x44, 0xf2, 0x15, 0x83,
	0xbd, 0x92, 0x22, 0xd0, 0x2c, 0x51, 0x6c, 0xc7, 0x93, 0xa8, 0x5b, 0x61, 0xb4, 0x05, 0x84, 0xee,
	0xe1, 0xd0, 0x73, 0x77, 0x40, 0xef, 0xa0, 0x2c, 0x55, 0xee, 0x3e, 0x29, 0x06, 0xa9, 0x0e, 0x42,
	0x8a, 0x5c, 0x76, 0xe3, 0x6e, 0x6d, 0x47, 0xbb, 0xae, 0x5b, 0x29, 0xc2, 0xbc, 0x0a, 0xb5, 0xb1,
	0x1d, 0x45, 0x0f, 0x82, 0xd0, 0xe9, 0xd6, 0xd9, 0xda, 0x04, 0x36, 0xbb, 0x50, 0x8d, 0xa6, 0xfe,
	0xe0, 0xc0, 0xf5, 0xba, 0xc0, 0x58, 0x4a, 0x90, 0x9c, 0x42, 0x7d, 0xdf, 0x8d, 0xce, 0xb8, 0x60,
	0xdb, 0x60, 0xc4, 0x41, 0x6c, 0x7b, 0xcc, 0x32, 0x65, 0x8b, 0x03, 0xc8, 0xd6, 0x76, 0x46, 0xae,
	0x7f, 0x1c, 0x51, 0xbe, 0x91, 0x65, 0x2b, 0x45, 0xa0, 0x49, 0x82, 0xf8, 0x1e, 0x0d, 0x77, 0xa5,
	0x05, 0x98, 0xc1, 0xca, 0x56, 0x0e, 0x8b, 0x3e, 0xb3, 0xcf, 0x54, 0xe9, 0xc7, 0x76, 0x4c, 0x2f,
	0xef, 0x33, 0xef, 0x69, 0xb0, 0x91, 0x21, 0x50, 0xc4, 0x69, 0xb6, 0xc1, 0x40, 0x5b, 0xcb, 0x4d,
	0xe5, 0x40, 0xa2, 0x20, 0x33, 0x3b, 0x77, 0x97, 0x14, 0x81, 0x8e, 0xc6, 0x80, 0xdd, 0x73, 0x3b,
	0xb6, 0x43, 0xb6, 0x9b, 0x4d, 0x4b, 0x45, 0x91, 0x3f, 0x68, 0xd0, 0xd8, 0x1d, 0xc4, 0xee, 0x79,
	0x11, 0xc5, 0x12, 0xdf, 0xd3, 0x15, 0xdf, 0x53, 0xf7, 0xb2, 0x9c, 0xdb, 0xcb, 0x27, 0xa1, 0x1e,
	0xda, 0xbe, 0x73, 0x87, 0x71, 0x30, 0xb8, 0xb4, 0x09, 0x02, 0x9f, 0x46, 0xee, 0xa9, 0x6f, 0xc7,
	0x93, 0x90, 0x32, 0xf7, 0xaa, 0x5b, 0x29, 0xe2, 0x61, 0x1e, 0x46, 0xde, 0xd6, 0xa0, 0x99, 0x6a,
	0xb2, 0x92, 0x7c, 0xc3, 0x9d, 0xea, 0x8c, 0xfa, 0x42, 0x11, 0x0e, 0x98, 0x4f, 0x43, 0x6d, 0x12,
	0xd1, 0xf0, 0xd0, 0x1f, 0x06, 0x4c, 0x89, 0xc6, 0xf3, 0x46, 0x0f, 0x43, 0xd3, 0x4a, 0xd0, 0x24,
	0x80, 0xd6, 0x41, 0x10, 0x9e, 0xd2, 0xf8, 0xc8, 0x2e, 0x90, 0x64, 0xb2, 0x96, 0xd0, 0xf3, 0x96,
	0x90, 0x56, 0x2f, 0xa7, 0x56, 0x27, 0xef, 0x68, 0xd0, 0x56, 0x39, 0x7e, 0xca, 0xfa, 0xff, 0x48,
	0x83, 0xda, 0xcb, 0xc1, 0xa9, 0xeb, 0xaf, 0xdf, 0xa7, 0xb2, 0x7e, 0x61, 0xcc, 0xf8, 0xc5, 0x0f,
	0x35, 0xa8, 0x0b, 0x51, 0x3e, 0x65, 0xa3, 0x7c, 0x1f, 0x60, 0xd7, 0x71, 0x18, 0x72, 0xa1, 0x55,
	0x12, 0xe2, 0x25, 0x95, 0xf8, 0x65, 0x6d, 0x82, 0xb9, 0x42, 0xc9, 0xdf, 0x1c, 0x20, 0x5f, 0x81,
	0xc6, 0xb1, 0x90, 0xe5, 0x92, 0x02, 0x90, 0x77, 0x35, 0x68, 0xa6, 0x6b, 0x57, 0x63, 0xc7, 0x27,
	0xa0, 0x8c, 0xa6, 0x61, 0xc2, 0x27, 0xd6, 0x62, 0x28, 0x73, 0x47, 0x95, 0xbf, 0xf1, 0x3c, 0xf4,
	0x92, 0x3c, 0x9f, 0xd3, 0xe5, 0x65, 0x37, 0x8a, 0x2f, 0xab, 0x8b, 0xc7, 0x55, 0xe1, 0x4b, 0x57,
	0xad, 0x8a, 0x9e, 0x53, 0x85, 0x44, 0xb0, 0x79, 0x3c, 0x76, 0xec, 0x98, 0x1e, 0x89, 0xcd, 0xb9,
	0xec, 0xde, 0x77, 0xa1, 0x1a, 0x78, 0x0e, 0xae, 0x16, 0x1c, 0x25, 0x88, 0x4f, 0x7c, 0xfa, 0x80,
	0x3d, 0xe1, 0x0e, 0x20, 0x41, 0xf2, 0x0a, 0xb4, 0xb8, 0x9b, 0xa1, 0xa7, 0xac, 0xc0, 0xd9, 0xc8,
	0x6b, 0xd0, 0xb9, 0x45, 0x63, 0xa4, 0xc9, 0xeb, 0xc6, 0x65, 0x69, 0x5e, 0x81, 0x0a, 0x0b, 0x03,
	0x47, 0x54, 0x2f, 0x01, 0x91, 0x73, 0xd8, 0xcc, 0xd1, 0x5d, 0xcd, 0x86, 0x5c, 0x03, 0xb0, 0x19,
	0xc1, 0x7d, 0x3b, 0xb6, 0x99, 0x75, 0x9a, 0x96, 0x82, 0x21, 0x36, 0x6c, 0xf1, 0x5d, 0x29, 0xae,
	0x52, 0x96, 0x85, 0x3e, 0xc3, 0x62, 0x0c, 0x1d, 0x8b, 0x46, 0x3c, 0x1f, 0x17, 0xd9, 0xf7, 0xac,
	0xc9, 0x5a, 0xd2, 0x64, 0x4b, 0x76, 0xfd, 0x0c, 0x5a, 0x37, 0x7d, 0xfb, 0xc4, 0xa3, 0x45, 0x52,
	0xcc, 0x22, 0x76, 0x57, 0xa0, 0x42, 0x19, 0x51, 0xc6, 0xad, 0x66, 0x09, 0x88, 0xf4, 0xa1, 0xb5,
	0x4f, 0x3d, 0x1a, 0xaf, 0x92, 0x19, 0x79, 0x13, 0xda, 0x7b, 0xf7, 0x6c, 0xff, 0x94, 0xf2, 0x58,
	0x5f, 0x91, 0x0a, 0x49, 0x36, 0x2c, 0xab, 0xd9, 0xf0, 0x0c, 0x5a, 0xfd, 0x81, 0xed, 0xbf, 0x1a,
	0xa2, 0x0b, 0x2d, 0x2d, 0x53, 0xf7, 0xc3, 0xc4, 0xf1, 0xea, 0x96, 0x80, 0x94, 0xf2, 0xa5, 0x67,
	0xca, 0xd7, 0xdc, 0xea, 0x40, 0xf6, 0x60, 0xeb, 0x16, 0x8d, 0xef, 0xe2, 0xef, 0x1b, 0xd3, 0x82,
	0x2c, 0xb1, 0x92, 0x6d, 0xcf, 0x52, 0x59, 0x67, 0x51, 0x4b, 0x95, 0x34, 0x32, 0x0d, 0xed, 0xbf,
	0x75, 0xa8, 0x1d, 0xb8, 0x1e, 0x3d, 0x8c, 0xe9, 0x48, 0x19, 0x48, 0xea, 0xcb, 0x06, 0x92, 0xc8,
	0x7d, 0x8b, 0xe7, 0x14, 0xdd, 0x62, 0xbf, 0xb1, 0x80, 0xb9, 0xd1, 0x41, 0xe0, 0x39, 0xa2, 0x06,
	0xd4, 0xac, 0x04, 0xce, 0x8e, 0x0b, 0x46, 0x7e, 0x5c, 0xc0, 0x11, 0x85, 0x45, 0x2f, 0x3e, 0xad,
	0xf0, 0xa7, 0x09, 0x82, 0x29, 0xe7, 0xbc, 0x20, 0x3a, 0x44, 0xfc, 0xc9, 0xb8, 0x63, 0xff, 0x5b,
	0x63, 0x5c, 0xd8, 0x6f, 0xe6, 0x14, 0xf7, 0xec, 0x90, 0xb2, 0x79, 0xa3, 0x66, 0x71, 0x00, 0x65,
	0x8a, 0x26, 0x27, 0xa8, 0x5a, 0x24, 0xa6, 0x8d, 0x04, 0x46, 0x2a, 0x67, 0xae, 0xef, 0x74, 0x1b,
	0x5c, 0x2f, 0xfc, 0x8d, 0x49, 0x80, 0x2d, 0xdc, 0x0b, 0x26, 0x7e, 0xdc, 0x6d, 0xb2, 0x15, 0x0a,
	0x06, 0x65, 0xa1, 0x17, 0x71, 0xb7, 0xc5, 0x65, 0xa1, 0x17, 0x62, 0xd4, 0x09, 0xa9, 0x1f, 0x1f,
	0x3a, 0xdd, 0xb6, 0x2c, 0xdb, 0x1c, 0x46, 0x6a, 0xfc, 0x37, 0x6b, 0x65, 0x36, 0x78, 0x2b, 0x93,
	0x62, 0xb8, 0xc5, 0xfa, 0xd3, 0x28, 0xa6, 0xa3, 0x6e, 0x87, 0x4b, 0x27, 0x61, 0xe4, 0x34, 0x70,
	0x9d, 0xee, 0x26, 0xe7, 0x34, 0x70, 0x19, 0xb5, 0x61, 0x10, 0x8e, 0xf8, 0xe0, 0xd1, 0x35, 0x39,
	0xb5, 0x14, 0xc3, 0x06, 0xab, 0xd8, 0x0e, 0xe3, 0xdd, 0xb8, 0xbb, 0xc5, 0x6c, 0x28, 0x41, 0xb4,
	0x0d, 0xf5, 0xd1, 0xb6, 0xdb, 0x0c, 0xcf, 0x01, 0xf2, 0x91, 0x06, 0xcd, 0x3b, 0xf4, 0x01, 0xdf,
	0xa1, 0xcb, 0xc6, 0x26, 0x77, 0x12, 0x7d, 0xc6, 0x49, 0xca, 0xf9, 0x8e, 0x46, 0x98, 0xc6, 0xc8,
	0x99, 0x46, 0x55, 0xbd, 0x92, 0x53, 0x3d, 0xab, 0x68, 0x35, 0xaf, 0x28, 0x39, 0x82, 0x96, 0x22,
	0x77, 0x91, 0x78, 0xc9, 0x49, 0x4f, 0xfe, 0xa6, 0x41, 0xeb, 0x78, 0xec, 0x05, 0xb6, 0x83, 0xae,
	0xb1, 0x8a, 0x6e, 0x8e, 0x73, 0x28, 0x27, 0xf6, 0x59, 0x66, 0x0b, 0x19, 0x4c, 0x15, 0x25, 0x98,
	0xfe, 0x1f, 0xe0, 0x64, 0x1a, 0xd3, 0xe8, 0x8d, 0x61, 0x18, 0x8c, 0x98, 0x0d, 0x74, 0xab, 0xce,
	0x30, 0x07, 0x61, 0x30, 0xc2, 0x25, 0x0e, 0x96, 0xa9, 0x1a, 0x2b, 0x53, 0xec, 0xb7, 0x8c, 0x93,
	0x7a, 0x12, 0x27, 0xe4, 0xb7, 0x38, 0xa7, 0x06, 0x0f, 0xfc, 0xa2, 0x8a, 0x5d, 0x81, 0xca, 0x10,
	0xb3, 0x42, 0x92, 0x13, 0x39, 0x94, 0x13, 0xae, 0x9c, 0x17, 0xee, 0x29, 0x68, 0xf0, 0xc7, 0x03,
	0x16, 0x45, 0x3c, 0xdc, 0xf9, 0x0a, 0x1e, 0x45, 0x69, 0x62, 0xaf, 0x64, 0xba, 0x87, 0xf7, 0x35,
	0xe8, 0x64, 0xe5, 0x5d, 0x4d, 0x32, 0x5c, 0xe0, 0x9c, 0xa8, 0x4d, 0x1f, 0x0d, 0xcf, 0x25, 0x4c,
	0xe0, 0xc4, 0xba, 0x95, 0xd4, 0xba, 0xe4, 0x83, 0x12, 0x34, 0x50, 0xa6, 0x02, 0x1d, 0x6a, 0x66,
	0xf3, 0xf5, 0xdc, 0xe6, 0x77, 0xa1, 0xea, 0xb8, 0xe1, 0x6d, 0x3b, 0x3a, 0x63, 0xe2, 0x19, 0x96,
	0x04, 0xa5, 0x84, 0x77, 0xa7, 0x63, 0x2e, 0xa1, 0x61, 0x25, 0x30, 0xcb, 0x6b, 0xb1, 0xcd, 0x97,
	0x89, 0xf0, 0x91, 0x30, 0x52, 0x3c, 0xa3, 0x53, 0x36, 0x47, 0xf0, 0xd8, 0x91, 0x20, 0x4a, 0x17,
	0x84, 0x98, 0x9e, 0x6b, 0xfc, 0xc8, 0x81, 0x01, 0xb8, 0x1b, 0xc1, 0x70, 0x18, 0xd1, 0x98, 0xb9,
	0x8e, 0x61, 0x09, 0x08, 0xdf, 0xf6, 0xdc, 0x91, 0x1b, 0x8b, 0xc4, 0xc9, 0x01, 0xa4, 0xee, 0x46,
	0x37, 0xef, 0x4f, 0x6c, 0x8f, 0x25, 0x4e, 0xc3, 0x92, 0x20, 0xce, 0x88, 0xcd, 0xd4, 0x42, 0x2b,
	0x2c, 0x63, 0xb1, 0xed, 0x09, 0xdb, 0x88, 0x53, 0xa0, 0xa7, 0xc0, 0x18, 0xb2, 0x94, 0x6e, 0xb0,
	0xfe, 0xbc, 0xde, 0x93, 0xb5, 0xcb, 0xe2, 0x78, 0xf2, 0x03, 0x0d, 0x5a, 0xdc, 0x81, 0x8a, 0x34,
	0xcc, 0x8b, 0xdc, 0xfe, 0x92, 0x39, 0x8e, 0x1c, 0x73, 0x21, 0x78, 0x5b, 0x55, 0x60, 0x4c, 0xe0,
	0x6c, 0xe5, 0x79, 0xa2, 0x04, 0x49, 0xc4, 0x1d, 0xf1, 0x76, 0x70, 0xbe, 0x32, 0xcd, 0x76, 0xa0,
	0xc1, 0x9a, 0x4e, 0xa1, 0x08, 0x57, 0x50, 0x45, 0x91, 0x3f, 0x6b, 0x9c, 0xeb, 0x5e, 0x30, 0x9e,
	0x7e, 0x62, 0x5c, 0xb1, 0x31, 0xf0, 0xe9, 0x83, 0x03, 0xbe, 0x58, 0x9c, 0x2f, 0x25, 0x08, 0xb1,
	0x1e, 0x01, 0x56, 0x5f, 0x2b, 0xc9, 0x7a, 0x89, 0x52, 0x12, 0x4d, 0x35, 0x93, 0x68, 0xfa, 0x5c,
	0x99, 0x7e, 0x81, 0x31, 0x61, 0xf1, 0xbe, 0x88, 0xed, 0x3e, 0xf6, 0xa3, 0x95, 0x92, 0xfd, 0x95,
	0x06, 0x0d, 0x8b, 0x0e, 0xa6, 0x83, 0x99, 0xf6, 0xcc, 0x60, 0x95, 0x25, 0xb5, 0x6e, 0x69, 0xae,
	0xb7, 0xea, 0x73, 0xda, 0xb6, 0xf2, 0x82, 0xb6, 0xcd, 0x58, 0xd6, 0xb6, 0x55, 0xf2, 0x6d, 0x9b,
	0x68, 0x86, 0xaa, 0x49, 0x33, 0x84, 0x2d, 0x45, 0x5b, 0xc8, 0x5a, 0x24, 0x4f, 0x26, 0xf9, 0x49,
	0x9f, 0x9f, 0x9f, 0xca, 0xf3, 0xf3, 0x93, 0x91, 0xcb, 0x4f, 0x0b, 0xb2, 0x9f, 0x9a, 0x4f, 0x6b,
	0xd9, 0x7c, 0x4a, 0xde, 0xd5, 0x60, 0x23, 0x23, 0xf8, 0x3a, 0xd3, 0x17, 0x01, 0xc3, 0x8d, 0xe9,
	0x48, 0xa6, 0xaf, 0x66, 0x4f, 0xd9, 0x5e, 0x8b, 0x3f, 0x22, 0x47, 0x38, 0x6d, 0x32, 0x6c, 0xb1,
	0xf4, 0xd1, 0x01, 0xdd, 0x15, 0xbe, 0x64, 0x58, 0xf8, 0x93, 0xbc, 0x0a, 0x9b, 0x82, 0xa2, 0x45,
	0xa3, 0x38, 0x08, 0x57, 0x40, 0xf2, 0x17, 0x22, 0xe3, 0xf7, 0xb1, 0x41, 0x5e, 0x99, 0xc7, 0x63,
	0xff, 0xc7, 0xe3, 0x14, 0xb7, 0x42, 0xa4, 0x05, 0x05, 0xa3, 0x36, 0xba, 0xc6, 0x82, 0x46, 0xb7,
	0xa2, 0x36, 0xba, 0xaf, 0x41, 0x9b, 0x07, 0xe6, 0x6a, 0xe5, 0x24, 0xaf, 0xc3, 0x26, 0x4b, 0x89,
	0x5e, 0x10, 0x15, 0x33, 0xc1, 0xa2, 0xb1, 0xf9, 0x2f, 0x25, 0x68, 0x32, 0x82, 0x45, 0x82, 0x68,
	0xd1, 0xd4, 0x7c, 0x95, 0x1f, 0x68, 0x2a, 0x1f, 0x16, 0x12, 0x78, 0x69, 0x77, 0xaa, 0x34, 0x28,
	0x95, 0xc5, 0x0d, 0x4a, 0x75, 0x49, 0x83, 0x52, 0x5b, 0xdc, 0xa0, 0xd4, 0x17, 0x34, 0x28, 0x30,
	0x3f, 0x01, 0x34, 0xe6, 0x27, 0x80, 0xa6, 0x9a, 0x00, 0x66, 0x46, 0x34, 0xf2, 0xa1, 0x0e, 0x75,
	0x66, 0xce, 0xb9, 0xe3, 0xed, 0x3a, 0xf3, 0xa7, 0x6a, 0x21, 0x5e, 0x9e, 0x52, 0x0b, 0x65, 0x72,
	0x6b, 0x75, 0xce, 0x17, 0xb4, 0x64, 0xb7, 0x6a, 0xb9, 0xdd, 0x4a, 0xbc, 0xbc, 0xae, 0x78, 0x39,
	0x56, 0x43, 0xd6, 0x6f, 0x1f, 0xd1, 0x60, 0xec, 0x51, 0x66, 0x41, 0xdd, 0x52, 0x51, 0xd2, 0x32,
	0x8d, 0x74, 0x78, 0x4d, 0x86, 0xe6, 0xa6, 0x3a, 0x34, 0x8b, 0x41, 0xa2, 0x95, 0x0e, 0xdc, 0xcb,
	0x86, 0x5c, 0x75, 0xc4, 0xee, 0xe4, 0x46, 0xec, 0xd9, 0x21, 0x56, 0x89, 0x5d, 0x33, 0x13, 0xbb,
	0xe4, 0x6d, 0x0d, 0x5a, 0x8a, 0xd3, 0xaf, 0x33, 0x01, 0xef, 0x64, 0x13, 0x30, 0xf4, 0x12, 0xef,
	0x90, 0xe9, 0xf7, 0x5b, 0xd0, 0x39, 0x8e, 0x68, 0x58, 0x38, 0x08, 0x15, 0x17, 0xd7, 0x33, 0x2e,
	0x4e, 0x7e, 0xad, 0xf1, 0xb3, 0xdc, 0x79, 0x0e, 0xb9, 0xbc, 0xa0, 0x2f, 0x38, 0x73, 0x5d, 0x1a,
	0xd8, 0x3b, 0xd0, 0x18, 0x32, 0x57, 0xdc, 0x53, 0x46, 0x31, 0x15, 0x85, 0x6e, 0x38, 0x64, 0x7d,
	0x1d, 0x3e, 0x17, 0x25, 0x3e, 0x41, 0x90, 0x9f, 0x6a, 0xb0, 0x99, 0x33, 0xc4, 0x3a, 0x37, 0xe6,
	0xf3, 0xd9, 0x8d, 0x69, 0xf7, 0x32, 0x96, 0x92, 0x9b, 0xf3, 0x4b, 0x0d, 0x3a, 0xe8, 0x5f, 0x37,
	0x1d, 0x37, 0xfe, 0x8c, 0x97, 0x9e, 0xef, 0xc2, 0xb6, 0xb8, 0x02, 0x70, 0x12, 0x04, 0x67, 0x37,
	0xec, 0xc1, 0xd9, 0x64, 0x5c, 0xe0, 0x60, 0x5a, 0xf9, 0x20, 0xa6, 0xcf, 0x7c, 0x8a, 0xef, 0x42,
	0x75, 0x10, 0xf8, 0x31, 0xf5, 0xa5, 0xc0, 0x12, 0x24, 0x56, 0x86, 0x7b, 0xb1, 0x46, 0x22, 0x3d,
	0x2a, 0x61, 0xde, 0x49, 0x6e, 0xc2, 0xff, 0xcd, 0xd0, 0xdc, 0xf5, 0xbc, 0xcb, 0x7e, 0xb4, 0xf1,
	0xc1, 0x54, 0xc8, 0x14, 0xac, 0x73, 0xa2, 0x2a, 0xe8, 0xf3, 0xab, 0x42, 0x59, 0xa9, 0x0a, 0x38,
	0x34, 0x29, 0xfc, 0x66, 0x2e, 0x5d, 0x5c, 0x85, 0xda, 0x09, 0xdb, 0x9c, 0xdd, 0x58, 0x5c, 0x2b,
	0x48, 0xe0, 0x47, 0xb0, 0xff, 0xcf, 0x35, 0xd8, 0x9a, 0xd1, 0x72, 0x9d, 0xf1, 0xf3, 0x45, 0x68,
	0xda, 0x29, 0xbf, 0xb4, 0xc1, 0x54, 0x84, 0xb0, 0x32, 0x6f, 0x90, 0x3e, 0x3c, 0xbe, 0x3b, 0x1e,
	0x07, 0xae, 0x1f, 0x8b, 0x77, 0x8a, 0x6c, 0x45, 0xde, 0x47, 0x3e, 0xd4, 0xe0, 0xca, 0x3c, 0xaa,
	0x9f, 0x2d, 0xd5, 0x2f, 0xc0, 0x14, 0x42, 0xae, 0xe3, 0x5c, 0x27, 0x7f, 0x1a, 0x6e, 0xa4, 0x6d,
	0x01, 0xf9, 0xa0, 0x04, 0x5b, 0x39, 0xd6, 0x8b, 0x4e, 0xde, 0x27, 0x13, 0x57, 0xd6, 0x01, 0xf6,
	0x7b, 0x6e, 0x5b, 0x22, 0x0a, 0x7b, 0x39, 0x2d, 0xec, 0xb2, 0x51, 0x31, 0xb2, 0x8d, 0x4a, 0x22,
	0x6d, 0x65, 0x89, 0xb4, 0xd5, 0x5c, 0x13, 0xb3, 0x0d, 0xc6, 0xd8, 0x8e, 0xef, 0x45, 0xa2, 0x0f,
	0xe1, 0xc0, 0xec, 0x69, 0x23, 0xd2, 0x18, 0xdc, 0x73, 0x3d, 0x27, 0xa4, 0x3e, 0xeb, 0x3e, 0xea,
	0x56, 0x02, 0xcb, 0x46, 0xa0, 0x91, 0x36, 0x02, 0xa2, 0xee, 0x1c, 0x31, 0xca, 0x4d, 0x3e, 0xda,
	0x27, 0x08, 0xf2, 0x33, 0x6d, 0xc6, 0x42, 0xeb, 0x75, 0x9f, 0xe7, 0xb2, 0x95, 0x67, 0xbb, 0x37,
	0x67, 0x7f, 0x64, 0xfd, 0xf9, 0xb1, 0xc6, 0x1b, 0x7f, 0x9e, 0xce, 0x8b, 0x38, 0x4e, 0xf6, 0x84,
	0x5b, 0x9f, 0x39, 0xca, 0xbf, 0xd4, 0xc8, 0x4b, 0xde, 0xd7, 0xc0, 0xcc, 0xcb, 0xf3, 0x59, 0xb1,
	0xd5, 0x11, 0x74, 0xfa, 0xd4, 0x0e, 0x07, 0xf7, 0xd8, 0x91, 0x95, 0xf3, 0x42, 0x81, 0xa1, 0x13,
	0xdd, 0x4c, 0x4f, 0x0f, 0xb5, 0x87, 0xb0, 0x99, 0xa3, 0xb8, 0x82, 0x2f, 0x00, 0xd2, 0x41, 0xcb,
	0x89, 0x83, 0x92, 0xbf, 0x27, 0x67, 0x88, 0x83, 0x62, 0x5f, 0x7b, 0xe7, 0x9e, 0x79, 0xa9, 0x41,
	0x58, 0x9e, 0xfd, 0x0e, 0xe0, 0xa7, 0x77, 0x5e, 0x92, 0xd0, 0x46, 0xb9, 0x2a, 0x69, 0xe0, 0xcc,
	0x7e, 0x0e, 0x53, 0x83, 0xb7, 0x96, 0x4d, 0x35, 0x49, 0x22, 0xa8, 0xa7, 0x89, 0x80, 0xbc, 0x09,
	0x6d, 0xee, 0x2a, 0xd1, 0xfa, 0xeb, 0xee, 0xf7, 0x60, 0x43, 0xe1, 0x35, 0xb7, 0xdf, 0xcd, 0xd6,
	0xd7, 0xd2, 0xbc, 0xab, 0x86, 0x69, 0x87, 0xca, 0x79, 0xa6, 0x88, 0xec, 0x18, 0x55, 0xce, 0x8d,
	0x51, 0xd8, 0xbf, 0x6e, 0x64, 0x74, 0x5d, 0x67, 0x5c, 0x3c, 0x9b, 0x8d, 0x8b, 0x4e, 0x2f, 0xa7,
	0xb9, 0x8c, 0x89, 0x29, 0xb4, 0xc4, 0x93, 0x5d, 0xc7, 0x59, 0x75, 0x37, 0x98, 0xb1, 0x56, 0x39,
	0x67, 0x2d, 0x12, 0xf3, 0xa3, 0x90, 0x97, 0x83, 0xd3, 0x82, 0x5b, 0x2f, 0x2e, 0x8b, 0xea, 0xf9,
	0xcb, 0xa2, 0x11, 0x0b, 0xc9, 0xbb, 0xae, 0x98, 0x41, 0x0c, 0x4b, 0xc1, 0x90, 0x3f, 0x69, 0xb0,
	0x91, 0x61, 0xbb, 0x9a, 0x5d, 0x48, 0xbf, 0xb1, 0xe5, 0x07, 0x27, 0x23, 0x3f, 0x38, 0xcd, 0xbd,
	0xe3, 0x7a, 0x05, 0x2a, 0x2e, 0x6f, 0xf4, 0x79, 0x30, 0x09, 0x68, 0xf9, 0xdd, 0x56, 0xf2, 0x6d,
	0x68, 0xf4, 0xa7, 0xfe, 0xa0, 0x60, 0xda, 0x5f, 0xb6, 0x77, 0xe4, 0x37, 0x1a, 0x34, 0x25, 0xed,
	0x42, 0xa1, 0x92, 0x3c, 0xc7, 0x2a, 0x9a, 0x65, 0x80, 0x18, 0xc5, 0x42, 0xe5, 0x05, 0x16, 0x32,
	0x32, 0x16, 0x5a, 0x7a, 0xfe, 0x4b, 0xde, 0x51, 0xc4, 0x5d, 0x6f, 0x64, 0x7d, 0x2e, 0x1b, 0x59,
	0xad, 0x9e, 0x6a, 0x25, 0x65, 0x2c, 0x04, 0xc4, 0xaf, 0x21, 0xa8, 0xb2, 0x76, 0x2d, 0x2f, 0xb1,
	0xeb, 0xff, 0xe4, 0x79, 0xe4, 0x77, 0x1a, 0x77, 0x22, 0x9c, 0x60, 0x1f, 0xb1, 0xd9, 0xce, 0xc9,
	0x5e, 0x7e, 0x88, 0xec, 0xc6, 0x12, 0xd9, 0x2b, 0x0b, 0x64, 0xaf, 0x66, 0x64, 0x7f, 0x91, 0x5b,
	0x79, 0x9f, 0x7a, 0x8f, 0x3a, 0x26, 0x9c, 0x40, 0xf3, 0x46, 0x70, 0xc1, 0xef, 0x6d, 0x09, 0x5a,
	0x7c, 0x95, 0x36, 0xa7, 0x03, 0x28, 0xa5, 0xf5, 0xae, 0x0b, 0xd5, 0x73, 0x1a, 0x46, 0x6e, 0xe0,
	0xcb, 0xc3, 0x15, 0x01, 0xe2, 0xbb, 0x93, 0xd0, 0x93, 0x55, 0x7c, 0x12, 0x7a, 0xe4, 0x2e, 0xb4,
	0x14, 0x1e, 0xd1, 0x38, 0xf1, 0x46, 0x6d, 0xd6, 0x1b, 0x53, 0x8d, 0x4b, 0x99, 0x28, 0x98, 0xfd,
	0xdf, 0xc2, 0x33, 0xd0, 0xe2, 0x9d, 0x9a, 0x72, 0xf7, 0x72, 0x56, 0x74, 0x12, 0xc9, 0x7b, 0xe6,
	0xc9, 0x35, 0xcb, 0x25, 0xdc, 0x15, 0xad, 0x4a, 0x59, 0xad, 0xda, 0x50, 0x8a, 0xa4, 0xaa, 0xa5,
	0xc8, 0x67, 0x29, 0x3e, 0xb4, 0x47, 0xf4, 0x41, 0x10, 0x9e, 0xc9, 0x3b, 0xe2, 0x09, 0x82, 0x3c,
	0x0b, 0xcd, 0x7d, 0x37, 0x3a, 0x63, 0xf9, 0x1e, 0x45, 0x4b, 0xef, 0xfc, 0x68, 0x99, 0x3b, 0x3f,
	0x1e, 0xb4, 0x94, 0xf7, 0x96, 0xcb, 0xb6, 0x03, 0x0d, 0xee, 0x31, 0xbc, 0xac, 0xf0, 0x09, 0x59,
	0x45, 0xa5, 0x5e, 0xc6, 0x6e, 0xe6, 0xf3, 0x6b, 0xf7, 0x0a, 0x86, 0x7c, 0x0d, 0x36, 0xf6, 0x58,
	0xe2, 0x78, 0xdd, 0xf6, 0x3c, 0xca, 0x04, 0x33, 0xa1, 0x1c, 0x4f, 0xc7, 0x54, 0xa4, 0x37, 0xf6,
	0x7b, 0xc1, 0x61, 0xc1, 0x97, 0xa1, 0x79, 0x8b, 0xc6, 0x45, 0x56, 0x7e, 0x15, 0x80, 0x2f, 0x63,
	0xe9, 0x74, 0xde, 0xba, 0x2e, 0x54, 0xc5, 0x54, 0x28, 0xcd, 0x2e, 0x40, 0x72, 0x1b, 0x5a, 0x0a,
	0xd7, 0xe5, 0x06, 0x7a, 0x5a, 0x26, 0xa8, 0x12, 0x4b, 0x50, 0x8d, 0x5e, 0xca, 0x55, 0xa6, 0xa7,
	0x5d, 0xd8, 0x48, 0xc8, 0xbd, 0x44, 0xa7, 0x8b, 0x1d, 0x7e, 0x99, 0x44, 0x9d, 0x2c, 0x89, 0xe5,
	0x42, 0x5d, 0x03, 0x10, 0x2b, 0x5f, 0xa2, 0x53, 0x59, 0x2d, 0x52, 0x0c, 0xf9, 0xbd, 0x06, 0x4d,
	0x7e, 0xc1, 0xf0, 0xc0, 0xf5, 0x0a, 0xf4, 0x02, 0xe2, 0x1e, 0xa1, 0xae, 0xde, 0x23, 0x64, 0x7f,
	0x09, 0xa0, 0x9e, 0x3d, 0x7d, 0x31, 0x48, 0x0e, 0xd0, 0x52, 0x04, 0xea, 0x36, 0x72, 0x7d, 0xe5,
	0x06, 0x9a, 0x04, 0xd9, 0x94, 0x19, 0xe2, 0x34, 0x54, 0x11, 0x53, 0x66, 0x28, 0xef, 0x34, 0xb9,
	0x6f, 0xd1, 0xfe, 0x44, 0xde, 0x81, 0x91, 0x20, 0x0e, 0x3d, 0x57, 0xd2, 0x2b, 0x3b, 0x77, 0x83,
	0x03, 0xd7, 0x1b, 0x04, 0xfc, 0x7e, 0x7a, 0x17, 0xaa, 0xee, 0x78, 0x18, 0xed, 0x25, 0xb3, 0xb4,
	0x04, 0x93, 0x8b, 0x1d, 0x25, 0xe5, 0xda, 0x8c, 0x7a, 0x11, 0x44, 0xcf, 0x5d, 0x04, 0x79, 0xc8,
	0x45, 0x97, 0x45, 0xd7, 0xe9, 0x7a, 0x60, 0xde, 0xa2, 0x31, 0xf6, 0x78, 0xc7, 0xe3, 0x3e, 0xcb,
	0x21, 0x4b, 0xc5, 0x22, 0x1f, 0x69, 0xec, 0x3a, 0x61, 0x76, 0xc1, 0x43, 0xb3, 0x85, 0x43, 0x6d,
	0x6f, 0x2f, 0x39, 0x1d, 0x90, 0x20, 0x9b, 0x30, 0x5c, 0x3a, 0xa0, 0x7b, 0x6e, 0x7a, 0x28, 0x21,
	0x60, 0x25, 0xc3, 0x89, 0xfa, 0x2f, 0x32, 0xdc, 0x55, 0xa8, 0xbd, 0x46, 0x43, 0x77, 0xe8, 0x52,
	0x47, 0x7e, 0xc3, 0x90, 0x30, 0x3e, 0xdb, 0x9f, 0x84, 0x76, 0x8c, 0x89, 0xa9, 0xc2, 0x8f, 0xc6,
	0x24, 0x4c, 0x9e, 0x81, 0xc6, 0x2d, 0x1a, 0xdf, 0xc6, 0x2d, 0x5c, 0x96, 0x6a, 0x6e, 0xb1, 0xf8,
	0x15, 0xaf, 0x2d, 0xd7, 0xeb, 0x49, 0x30, 0x98, 0x47, 0x88, 0x40, 0xaa, 0xf4, 0xf8, 0x2a, 0x8e,
	0x24, 0x01, 0x18, 0x0c, 0x46, 0xf5, 0x6f, 0x0b, 0x3f, 0x12, 0xb6, 0x14, 0x20, 0x3e, 0xe9, 0xc7,
	0x41, 0x68, 0x9f, 0xca, 0xfe, 0x48, 0x82, 0xe8, 0x61, 0x47, 0x61, 0x3a, 0x6f, 0x73, 0x00, 0xfd,
	0xd5, 0xca, 0xfb, 0x6b, 0x82, 0x20, 0x23, 0xd8, 0xdc, 0x73, 0x9d, 0x4f, 0x6c, 0x5a, 0xfa, 0x97,
	0x06, 0x66, 0x96, 0xdf, 0xdc, 0x36, 0x50, 0x89, 0xa2, 0xd2, 0x82, 0x28, 0xd2, 0xd5, 0x28, 0x5a,
	0x3a, 0x23, 0x65, 0x27, 0x06, 0x23, 0xf7, 0x05, 0x00, 0x53, 0x7f, 0x34, 0x19, 0x0c, 0x68, 0x14,
	0x61, 0x9c, 0x89, 0x26, 0x50, 0x45, 0xa9, 0xae, 0x58, 0x9d, 0x71, 0xc5, 0x24, 0xb4, 0x6a, 0xd9,
	0xd0, 0x22, 0xef, 0xcd, 0xa8, 0xba, 0xde, 0x16, 0xf2, 0x0b, 0xd9, 0x16, 0x72, 0xab, 0x37, 0x6b,
	0x67, 0x99, 0xa9, 0xbf, 0x2e, 0xe7, 0xe3, 0xa4, 0x86, 0x5e, 0xe6, 0x64, 0xfb, 0x4d, 0x39, 0x71,
	0xa6, 0x95, 0x75, 0x5d, 0x4a, 0x3d, 0xf7, 0x9f, 0x12, 0x94, 0x71, 0x99, 0xd9, 0x80, 0x6a, 0x9f,
	0x6f, 0x49, 0xe7, 0x31, 0x04, 0x0e, 0x6c, 0xd7, 0x9b, 0x84, 0xb4, 0xa3, 0x99, 0xdb, 0xd0, 0x39,
	0xf4, 0xcf, 0x6d, 0xcf, 0x75, 0xfa, 0xf2, 0x0f, 0x47, 0x9d, 0x92, 0xd9, 0x06, 0x60, 0xd7, 0x8e,
	0x6f, 0x86, 0x61, 0x10, 0x76, 0x74, 0xb3, 0x03, 0x4d, 0x0e, 0x5f, 0x8c, 0xdd, 0x90, 0x3a, 0x9d,
	0xb2, 0xb9, 0x25, 0xff, 0xe2, 0x26, 0xff, 0x83, 0xe5, 0x74, 0x0c, 0xa4, 0xbc, 0x7f, 0xc2, 0xd7,
	0x54, 0x10, 0x38, 0x0c, 0x38, 0x50, 0x35, 0x37, 0xf9, 0x57, 0xad, 0x23, 0x3b, 0x8a, 0x38, 0xaa,
	0x66, 0x3e, 0x0e, 0x9b, 0x16, 0xbd, 0x3f, 0xa1, 0x51, 0x7c, 0x64, 0x87, 0xf6, 0x88, 0xa3, 0xeb,
	0xf8, 0xe6, 0x9d, 0xe0, 0xa6, 0x1f, 0x4c, 0x4e, 0xef, 0xb1, 0x5b, 0xe1, 0x1d, 0x40, 0xee, 0x77,
	0x68, 0x8c, 0xdd, 0x0b, 0x7f, 0xa9, 0x61, 0x9a, 0xd0, 0x16, 0x6b, 0x71, 0x80, 0x0c, 0x26, 0x71,
	0xa7, 0x89, 0x6f, 0x21, 0x8b, 0x7d, 0x37, 0xc2, 0x42, 0xe3, 0x74, 0x5a, 0x28, 0x23, 0x62, 0x98,
	0xa1, 0x0f, 0xa3, 0x57, 0xce, 0x69, 0xd8, 0x69, 0x23, 0x7d, 0x79, 0xff, 0xe7, 0xe6, 0x85, 0x1b,
	0xc5, 0x9d, 0x0d, 0xb4, 0xc1, 0xb1, 0xf8, 0x22, 0x76, 0x27, 0x88, 0x39, 0xb6, 0x83, 0x36, 0xe0,
	0x17, 0x4e, 0xf1, 0xf5, 0xce, 0xa6, 0xd9, 0x82, 0x3a, 0x6e, 0x9c, 0xeb, 0x9f, 0x1e, 0x8f, 0x3b,
	0x26, 0x3e, 0xbe, 0xed, 0xbc, 0x70, 0x18, 0xf1, 0xd7, 0xb7, 0x90, 0x08, 0x3a, 0xee, 0xa1, 0x1f,
	0x4d, 0x86, 0x43, 0x77, 0xe0, 0x52, 0x3f, 0xee, 0x6c, 0xdf, 0xd8, 0xfe, 0xe3, 0xc7, 0xd7, 0xb4,
	0xbf, 0x7e, 0x7c, 0x4d, 0xfb, 0xc7, 0xc7, 0xd7, 0xb4, 0xf7, 0xfe, 0x79, 0xed, 0xb1, 0xef, 0x94,
	0xc6, 0x27, 0x27, 0x15, 0xf6, 0xe7, 0xde, 0x2f, 0xfd, 0x37, 0x00, 0x00, 0xff, 0xff, 0x40, 0x40,
	0xa4, 0xac, 0xe9, 0x3b, 0x00, 0x00,
}

func (m *RelayReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelayReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RelayReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BodyBuffer) > 0 {
		i -= len(m.BodyBuffer)
		copy(dAtA[i:], m.BodyBuffer)
		i = encodeVarintBox(dAtA, i, uint64(len(m.BodyBuffer)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProtocolId) > 0 {
		i -= len(m.ProtocolId)
		copy(dAtA[i:], m.ProtocolId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.ProtocolId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RelayResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelayResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RelayResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BodyBuffer) > 0 {
		i -= len(m.BodyBuffer)
		copy(dAtA[i:], m.BodyBuffer)
		i = encodeVarintBox(dAtA, i, uint64(len(m.BodyBuffer)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProtocolId) > 0 {
		i -= len(m.ProtocolId)
		copy(dAtA[i:], m.ProtocolId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.ProtocolId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommonResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommonResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PingReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PingReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PingReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PingResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PingResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PingResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerAddressReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerAddressReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerAddressReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerAddressResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerAddressResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerAddressResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PeerAddress) > 0 {
		for iNdEx := len(m.PeerAddress) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PeerAddress[iNdEx])
			copy(dAtA[i:], m.PeerAddress[iNdEx])
			i = encodeVarintBox(dAtA, i, uint64(len(m.PeerAddress[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *User) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *User) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *User) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SyncFil != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.SyncFil))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x4a
	}
	if m.CreatedAt != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x40
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintBox(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Status != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if m.UsedSpace != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.UsedSpace))
		i--
		dAtA[i] = 0x28
	}
	if m.AllocatedSpace != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.AllocatedSpace))
		i--
		dAtA[i] = 0x20
	}
	if m.Role != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DiskSpace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskSpace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiskSpace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OtherAllocated != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.OtherAllocated))
		i--
		dAtA[i] = 0x18
	}
	if m.AdminUsed != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.AdminUsed))
		i--
		dAtA[i] = 0x10
	}
	if m.Total != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeviceStateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceStateReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceStateReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeviceStateResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceStateResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceStateResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AdminAvatar) > 0 {
		i -= len(m.AdminAvatar)
		copy(dAtA[i:], m.AdminAvatar)
		i = encodeVarintBox(dAtA, i, uint64(len(m.AdminAvatar)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AdminName) > 0 {
		i -= len(m.AdminName)
		copy(dAtA[i:], m.AdminName)
		i = encodeVarintBox(dAtA, i, uint64(len(m.AdminName)))
		i--
		dAtA[i] = 0x22
	}
	if m.State != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActivateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivateReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActivateReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintBox(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.RandNonce) > 0 {
		i -= len(m.RandNonce)
		copy(dAtA[i:], m.RandNonce)
		i = encodeVarintBox(dAtA, i, uint64(len(m.RandNonce)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActivateResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivateResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActivateResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserInfo != nil {
		{
			size, err := m.UserInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBox(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ForgetPassReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForgetPassReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForgetPassReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ForgetPassResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForgetPassResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForgetPassResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserInfo != nil {
		{
			size, err := m.UserInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBox(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LoginReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintBox(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LoginResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserInfo != nil {
		{
			size, err := m.UserInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBox(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddUserReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddUserReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddUserReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Space != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Space))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserInfoResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserInfoResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserInfoResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Space != nil {
		{
			size, err := m.Space.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBox(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.User != nil {
		{
			size, err := m.User.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBox(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.User) > 0 {
		for iNdEx := len(m.User) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.User[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBox(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdatePasswordReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdatePasswordReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdatePasswordReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NewPass) > 0 {
		i -= len(m.NewPass)
		copy(dAtA[i:], m.NewPass)
		i = encodeVarintBox(dAtA, i, uint64(len(m.NewPass)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OldPass) > 0 {
		i -= len(m.OldPass)
		copy(dAtA[i:], m.OldPass)
		i = encodeVarintBox(dAtA, i, uint64(len(m.OldPass)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserRenameReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRenameReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserRenameReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetUserAvatarReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserAvatarReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUserAvatarReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetUserAvatarResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserAvatarResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUserAvatarResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AvatarData) > 0 {
		i -= len(m.AvatarData)
		copy(dAtA[i:], m.AvatarData)
		i = encodeVarintBox(dAtA, i, uint64(len(m.AvatarData)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateUserAvatarReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserAvatarReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateUserAvatarReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AvatarData) > 0 {
		i -= len(m.AvatarData)
		copy(dAtA[i:], m.AvatarData)
		i = encodeVarintBox(dAtA, i, uint64(len(m.AvatarData)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResetPasswordReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetPasswordReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetPasswordReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NewPass) > 0 {
		i -= len(m.NewPass)
		copy(dAtA[i:], m.NewPass)
		i = encodeVarintBox(dAtA, i, uint64(len(m.NewPass)))
		i--
		dAtA[i] = 0x22
	}
	if m.UserId != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EnableUserReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnableUserReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnableUserReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Enable {
		i--
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.UserId != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteUserReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteUserReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteUserReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChangeSpaceReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeSpaceReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangeSpaceReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Space != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Space))
		i--
		dAtA[i] = 0x20
	}
	if m.UserId != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ScanQrcodeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanQrcodeReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanQrcodeReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Qrcode) > 0 {
		i -= len(m.Qrcode)
		copy(dAtA[i:], m.Qrcode)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Qrcode)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTokenByQrcodeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTokenByQrcodeReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTokenByQrcodeReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Qrcode) > 0 {
		i -= len(m.Qrcode)
		copy(dAtA[i:], m.Qrcode)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Qrcode)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTokenByQrcodeResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTokenByQrcodeResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTokenByQrcodeResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EndAt != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.EndAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.StartAt != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.StartAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.FormDevice) > 0 {
		i -= len(m.FormDevice)
		copy(dAtA[i:], m.FormDevice)
		i = encodeVarintBox(dAtA, i, uint64(len(m.FormDevice)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.IsSystem != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.IsSystem))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.ParentName) > 0 {
		i -= len(m.ParentName)
		copy(dAtA[i:], m.ParentName)
		i = encodeVarintBox(dAtA, i, uint64(len(m.ParentName)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.ParentId) > 0 {
		i -= len(m.ParentId)
		copy(dAtA[i:], m.ParentId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.ParentId)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Ext) > 0 {
		i -= len(m.Ext)
		copy(dAtA[i:], m.Ext)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Ext)))
		i--
		dAtA[i] = 0x6a
	}
	if m.ShareCount != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.ShareCount))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0x5a
	}
	if m.SubFiles != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.SubFiles))
		i--
		dAtA[i] = 0x50
	}
	if m.Share {
		i--
		if m.Share {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Star {
		i--
		if m.Star {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Md5) > 0 {
		i -= len(m.Md5)
		copy(dAtA[i:], m.Md5)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Md5)))
		i--
		dAtA[i] = 0x3a
	}
	if m.UpdatedAt != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.UpdatedAt))
		i--
		dAtA[i] = 0x30
	}
	if m.CreatedAt != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x28
	}
	if m.IsFolder {
		i--
		if m.IsFolder {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Size_ != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NewFolderReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewFolderReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NewFolderReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FormDevice) > 0 {
		i -= len(m.FormDevice)
		copy(dAtA[i:], m.FormDevice)
		i = encodeVarintBox(dAtA, i, uint64(len(m.FormDevice)))
		i--
		dAtA[i] = 0x3a
	}
	if m.IsSystem != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.IsSystem))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ParentId) > 0 {
		i -= len(m.ParentId)
		copy(dAtA[i:], m.ParentId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.ParentId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NewFolderResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewFolderResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NewFolderResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UploadFileReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadFileReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadFileReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Md5) > 0 {
		i -= len(m.Md5)
		copy(dAtA[i:], m.Md5)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Md5)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x42
	}
	if m.BytesFrom != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.BytesFrom))
		i--
		dAtA[i] = 0x38
	}
	if m.Size_ != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ParentId) > 0 {
		i -= len(m.ParentId)
		copy(dAtA[i:], m.ParentId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.ParentId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DownloadFileReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadFileReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadFileReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x30
	}
	if m.BytesCount != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.BytesCount))
		i--
		dAtA[i] = 0x28
	}
	if m.BytesFrom != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.BytesFrom))
		i--
		dAtA[i] = 0x20
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DownloadFileResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadFileResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownloadFileResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x32
	}
	if m.FileSize != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsEqual != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.IsEqual))
		i--
		dAtA[i] = 0x58
	}
	if m.Limit != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x50
	}
	if m.Offset != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x48
	}
	if m.Order != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Keyword) > 0 {
		i -= len(m.Keyword)
		copy(dAtA[i:], m.Keyword)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Keyword)))
		i--
		dAtA[i] = 0x3a
	}
	if m.StarMask != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.StarMask))
		i--
		dAtA[i] = 0x30
	}
	if m.FileType != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.FileType))
		i--
		dAtA[i] = 0x28
	}
	if m.DirMask != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.DirMask))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ParentId) > 0 {
		i -= len(m.ParentId)
		copy(dAtA[i:], m.ParentId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.ParentId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Files) > 0 {
		for iNdEx := len(m.Files) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Files[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBox(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Total != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileRenameReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileRenameReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileRenameReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ParentId) > 0 {
		i -= len(m.ParentId)
		copy(dAtA[i:], m.ParentId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.ParentId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileDeleteReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileDeleteReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileDeleteReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FileIds) > 0 {
		for iNdEx := len(m.FileIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FileIds[iNdEx])
			copy(dAtA[i:], m.FileIds[iNdEx])
			i = encodeVarintBox(dAtA, i, uint64(len(m.FileIds[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileMoveReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileMoveReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileMoveReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NewParentId) > 0 {
		i -= len(m.NewParentId)
		copy(dAtA[i:], m.NewParentId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.NewParentId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileCopyReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileCopyReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileCopyReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x38
	}
	if len(m.NewFileName) > 0 {
		i -= len(m.NewFileName)
		copy(dAtA[i:], m.NewFileName)
		i = encodeVarintBox(dAtA, i, uint64(len(m.NewFileName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.NewFileId) > 0 {
		i -= len(m.NewFileId)
		copy(dAtA[i:], m.NewFileId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.NewFileId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NewParentId) > 0 {
		i -= len(m.NewParentId)
		copy(dAtA[i:], m.NewParentId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.NewParentId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileStarReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileStarReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileStarReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FileIds) > 0 {
		for iNdEx := len(m.FileIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FileIds[iNdEx])
			copy(dAtA[i:], m.FileIds[iNdEx])
			i = encodeVarintBox(dAtA, i, uint64(len(m.FileIds[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileUnstarReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileUnstarReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileUnstarReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FileIds) > 0 {
		for iNdEx := len(m.FileIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FileIds[iNdEx])
			copy(dAtA[i:], m.FileIds[iNdEx])
			i = encodeVarintBox(dAtA, i, uint64(len(m.FileIds[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecycleItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecycleItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecycleItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ext) > 0 {
		i -= len(m.Ext)
		copy(dAtA[i:], m.Ext)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Ext)))
		i--
		dAtA[i] = 0x3a
	}
	if m.CreatedAt != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x30
	}
	if m.IsFolder {
		i--
		if m.IsFolder {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Size_ != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecycleListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecycleListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecycleListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FileType != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.FileType))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Keyword) > 0 {
		i -= len(m.Keyword)
		copy(dAtA[i:], m.Keyword)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Keyword)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Limit != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x28
	}
	if m.Offset != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x20
	}
	if m.Order != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecycleListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecycleListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecycleListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBox(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Total != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecycleDeleteReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecycleDeleteReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecycleDeleteReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ids) > 0 {
		dAtA7 := make([]byte, len(m.Ids)*10)
		var j6 int
		for _, num1 := range m.Ids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintBox(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecycleRestoreReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecycleRestoreReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecycleRestoreReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ids) > 0 {
		dAtA9 := make([]byte, len(m.Ids)*10)
		var j8 int
		for _, num1 := range m.Ids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintBox(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileShareReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileShareReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileShareReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EndAt != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.EndAt))
		i--
		dAtA[i] = 0x30
	}
	if m.StartAt != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.StartAt))
		i--
		dAtA[i] = 0x28
	}
	if len(m.UserIdList) > 0 {
		i -= len(m.UserIdList)
		copy(dAtA[i:], m.UserIdList)
		i = encodeVarintBox(dAtA, i, uint64(len(m.UserIdList)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FileIds) > 0 {
		for iNdEx := len(m.FileIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FileIds[iNdEx])
			copy(dAtA[i:], m.FileIds[iNdEx])
			i = encodeVarintBox(dAtA, i, uint64(len(m.FileIds[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileUnShareReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileUnShareReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileUnShareReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FileIds) > 0 {
		for iNdEx := len(m.FileIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FileIds[iNdEx])
			copy(dAtA[i:], m.FileIds[iNdEx])
			i = encodeVarintBox(dAtA, i, uint64(len(m.FileIds[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileCloseShareReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileCloseShareReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileCloseShareReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShareListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShareListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShareListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ext) > 0 {
		i -= len(m.Ext)
		copy(dAtA[i:], m.Ext)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Ext)))
		i--
		dAtA[i] = 0x6a
	}
	if m.Limit != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x60
	}
	if m.Offset != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x58
	}
	if m.Order != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Keyword) > 0 {
		i -= len(m.Keyword)
		copy(dAtA[i:], m.Keyword)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Keyword)))
		i--
		dAtA[i] = 0x4a
	}
	if m.StarMask != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.StarMask))
		i--
		dAtA[i] = 0x40
	}
	if m.FileType != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.FileType))
		i--
		dAtA[i] = 0x38
	}
	if m.DirMask != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.DirMask))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ParentId) > 0 {
		i -= len(m.ParentId)
		copy(dAtA[i:], m.ParentId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.ParentId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintBox(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x22
	}
	if m.UserId != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShareItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShareItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShareItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StartAt != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.StartAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.SubFiles != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.SubFiles))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.ParentId) > 0 {
		i -= len(m.ParentId)
		copy(dAtA[i:], m.ParentId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.ParentId)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Md5) > 0 {
		i -= len(m.Md5)
		copy(dAtA[i:], m.Md5)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Md5)))
		i--
		dAtA[i] = 0x6a
	}
	if m.Share {
		i--
		if m.Share {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if len(m.Ext) > 0 {
		i -= len(m.Ext)
		copy(dAtA[i:], m.Ext)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Ext)))
		i--
		dAtA[i] = 0x5a
	}
	if m.CountPeople != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.CountPeople))
		i--
		dAtA[i] = 0x50
	}
	if m.EndAt != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.EndAt))
		i--
		dAtA[i] = 0x48
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintBox(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x42
	}
	if m.CreatedAt != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x38
	}
	if len(m.FileType) > 0 {
		i -= len(m.FileType)
		copy(dAtA[i:], m.FileType)
		i = encodeVarintBox(dAtA, i, uint64(len(m.FileType)))
		i--
		dAtA[i] = 0x32
	}
	if m.IsFolder {
		i--
		if m.IsFolder {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Size_ != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShareListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShareListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShareListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBox(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Total != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserShareListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserShareListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserShareListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Keyword) > 0 {
		i -= len(m.Keyword)
		copy(dAtA[i:], m.Keyword)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Keyword)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserShareItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserShareItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserShareItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FileCount != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.FileCount))
		i--
		dAtA[i] = 0x30
	}
	if m.FolderCount != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.FolderCount))
		i--
		dAtA[i] = 0x28
	}
	if len(m.UserName) > 0 {
		i -= len(m.UserName)
		copy(dAtA[i:], m.UserName)
		i = encodeVarintBox(dAtA, i, uint64(len(m.UserName)))
		i--
		dAtA[i] = 0x22
	}
	if m.UserId != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserShareListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserShareListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserShareListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBox(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Total != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileEditShareReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileEditShareReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileEditShareReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EndAt != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.EndAt))
		i--
		dAtA[i] = 0x30
	}
	if m.StartAt != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.StartAt))
		i--
		dAtA[i] = 0x28
	}
	if len(m.UserIdList) > 0 {
		i -= len(m.UserIdList)
		copy(dAtA[i:], m.UserIdList)
		i = encodeVarintBox(dAtA, i, uint64(len(m.UserIdList)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FileIds) > 0 {
		for iNdEx := len(m.FileIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FileIds[iNdEx])
			copy(dAtA[i:], m.FileIds[iNdEx])
			i = encodeVarintBox(dAtA, i, uint64(len(m.FileIds[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddressbookBackupReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressbookBackupReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressbookBackupReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintBox(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddressbookDeleteReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressbookDeleteReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressbookDeleteReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddressbookDeleteAllReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressbookDeleteAllReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressbookDeleteAllReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddressbookListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressbookListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressbookListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x20
	}
	if m.Offset != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Addressbook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Addressbook) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Addressbook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintBox(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BackupAt != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.BackupAt))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddressbookListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressbookListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddressbookListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Addressbooks) > 0 {
		for iNdEx := len(m.Addressbooks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Addressbooks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBox(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Total != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppointAddressListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppointAddressListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppointAddressListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppointAddressListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppointAddressListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppointAddressListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Addressbooks) > 0 {
		for iNdEx := len(m.Addressbooks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Addressbooks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBox(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Total != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppointFileListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppointFileListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppointFileListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsFolder != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.IsFolder))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ParentId) > 0 {
		i -= len(m.ParentId)
		copy(dAtA[i:], m.ParentId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.ParentId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppointFileListItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppointFileListItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppointFileListItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FilePaths) > 0 {
		i -= len(m.FilePaths)
		copy(dAtA[i:], m.FilePaths)
		i = encodeVarintBox(dAtA, i, uint64(len(m.FilePaths)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Children) > 0 {
		i -= len(m.Children)
		copy(dAtA[i:], m.Children)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Children)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Md5) > 0 {
		i -= len(m.Md5)
		copy(dAtA[i:], m.Md5)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Md5)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Paths) > 0 {
		i -= len(m.Paths)
		copy(dAtA[i:], m.Paths)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Paths)))
		i--
		dAtA[i] = 0x42
	}
	if m.IsFolder {
		i--
		if m.IsFolder {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.ParentId) > 0 {
		i -= len(m.ParentId)
		copy(dAtA[i:], m.ParentId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.ParentId)))
		i--
		dAtA[i] = 0x32
	}
	if m.Size_ != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Ext) > 0 {
		i -= len(m.Ext)
		copy(dAtA[i:], m.Ext)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Ext)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppointFileListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppointFileListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppointFileListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBox(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Total != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileBackupListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileBackupListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileBackupListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x28
	}
	if m.Offset != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x20
	}
	if len(m.FormDevice) > 0 {
		i -= len(m.FormDevice)
		copy(dAtA[i:], m.FormDevice)
		i = encodeVarintBox(dAtA, i, uint64(len(m.FormDevice)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileBackupListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileBackupListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileBackupListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBox(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Total != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchFileMd5Req) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchFileMd5Req) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchFileMd5Req) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Md5) > 0 {
		i -= len(m.Md5)
		copy(dAtA[i:], m.Md5)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Md5)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchFileMd5Resp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchFileMd5Resp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchFileMd5Resp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileRecordReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileRecordReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileRecordReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Size_ != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x48
	}
	if m.IsFolder != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.IsFolder))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Md5) > 0 {
		i -= len(m.Md5)
		copy(dAtA[i:], m.Md5)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Md5)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Cid) > 0 {
		i -= len(m.Cid)
		copy(dAtA[i:], m.Cid)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Cid)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ParentId) > 0 {
		i -= len(m.ParentId)
		copy(dAtA[i:], m.ParentId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.ParentId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BackupsListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupsListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupsListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x20
	}
	if m.Offset != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BackupsListItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupsListItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupsListItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreatedAt != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x20
	}
	if m.FileCount != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.FileCount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintBox(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BackupsListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupsListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupsListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBox(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Total != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BackupsAddReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupsAddReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupsAddReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FileCount != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.FileCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintBox(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileLogListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileLogListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileLogListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SearchTime != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.SearchTime))
		i--
		dAtA[i] = 0x20
	}
	if m.Status != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileLogListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileLogListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileLogListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreatedAt != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x40
	}
	if len(m.IdList) > 0 {
		i -= len(m.IdList)
		copy(dAtA[i:], m.IdList)
		i = encodeVarintBox(dAtA, i, uint64(len(m.IdList)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Status != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Id != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintBox(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncListItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncListItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncListItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreatedAt != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x30
	}
	if m.Status != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DevicePath) > 0 {
		i -= len(m.DevicePath)
		copy(dAtA[i:], m.DevicePath)
		i = encodeVarintBox(dAtA, i, uint64(len(m.DevicePath)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintBox(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBox(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Total != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncAddReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncAddReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncAddReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DevicePath) > 0 {
		i -= len(m.DevicePath)
		copy(dAtA[i:], m.DevicePath)
		i = encodeVarintBox(dAtA, i, uint64(len(m.DevicePath)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintBox(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncEditReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncEditReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncEditReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DevicePath) > 0 {
		i -= len(m.DevicePath)
		copy(dAtA[i:], m.DevicePath)
		i = encodeVarintBox(dAtA, i, uint64(len(m.DevicePath)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintBox(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x22
	}
	if m.Id != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncDelReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncDelReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncDelReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BoxUpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BoxUpdateReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BoxUpdateReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Md5) > 0 {
		i -= len(m.Md5)
		copy(dAtA[i:], m.Md5)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Md5)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BoxUpdateResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BoxUpdateResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BoxUpdateResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeviceInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeviceInfoResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceInfoResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceInfoResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Framework) > 0 {
		i -= len(m.Framework)
		copy(dAtA[i:], m.Framework)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Framework)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Sn) > 0 {
		i -= len(m.Sn)
		copy(dAtA[i:], m.Sn)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Sn)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DiskCountReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskCountReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiskCountReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DiskCountResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiskCountResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiskCountResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DeviceUsed != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.DeviceUsed))
		i--
		dAtA[i] = 0x18
	}
	if m.DeviceCount != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.DeviceCount))
		i--
		dAtA[i] = 0x10
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateWalletReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateWalletReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateWalletReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetWalletReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWalletReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWalletReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WalletItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WalletItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WalletItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetWalletResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWalletResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWalletResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBox(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetWalletKeyReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWalletKeyReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWalletKeyReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetWalletKeyResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetWalletKeyResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetWalletKeyResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AddressKey) > 0 {
		i -= len(m.AddressKey)
		copy(dAtA[i:], m.AddressKey)
		i = encodeVarintBox(dAtA, i, uint64(len(m.AddressKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EnableFilReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnableFilReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnableFilReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SizeSum != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.SizeSum))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Price) > 0 {
		i -= len(m.Price)
		copy(dAtA[i:], m.Price)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Price)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.MinerId) > 0 {
		i -= len(m.MinerId)
		copy(dAtA[i:], m.MinerId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.MinerId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RelayHost) > 0 {
		i -= len(m.RelayHost)
		copy(dAtA[i:], m.RelayHost)
		i = encodeVarintBox(dAtA, i, uint64(len(m.RelayHost)))
		i--
		dAtA[i] = 0x22
	}
	if m.Enable {
		i--
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UploadFileToFilcoinReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadFileToFilcoinReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadFileToFilcoinReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.BytesFrom != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.BytesFrom))
		i--
		dAtA[i] = 0x20
	}
	if m.FileSize != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.IpfsCid) > 0 {
		i -= len(m.IpfsCid)
		copy(dAtA[i:], m.IpfsCid)
		i = encodeVarintBox(dAtA, i, uint64(len(m.IpfsCid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetBackUpStatusReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBackUpStatusReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBackUpStatusReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IpfsCid) > 0 {
		i -= len(m.IpfsCid)
		copy(dAtA[i:], m.IpfsCid)
		i = encodeVarintBox(dAtA, i, uint64(len(m.IpfsCid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetBackUpStatusResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetBackUpStatusResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetBackUpStatusResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Duration != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x30
	}
	if m.Verified {
		i--
		if m.Verified {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PieceCid) > 0 {
		i -= len(m.PieceCid)
		copy(dAtA[i:], m.PieceCid)
		i = encodeVarintBox(dAtA, i, uint64(len(m.PieceCid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DealCid) > 0 {
		i -= len(m.DealCid)
		copy(dAtA[i:], m.DealCid)
		i = encodeVarintBox(dAtA, i, uint64(len(m.DealCid)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetMinerReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMinerReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMinerReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PeerId) > 0 {
		i -= len(m.PeerId)
		copy(dAtA[i:], m.PeerId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.PeerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetMinerResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMinerResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMinerResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Miner) > 0 {
		for iNdEx := len(m.Miner) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Miner[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBox(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Miner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Miner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Miner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RelayHost) > 0 {
		i -= len(m.RelayHost)
		copy(dAtA[i:], m.RelayHost)
		i = encodeVarintBox(dAtA, i, uint64(len(m.RelayHost)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Price) > 0 {
		i -= len(m.Price)
		copy(dAtA[i:], m.Price)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Price)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Storage) > 0 {
		i -= len(m.Storage)
		copy(dAtA[i:], m.Storage)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Storage)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MinerId) > 0 {
		i -= len(m.MinerId)
		copy(dAtA[i:], m.MinerId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.MinerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CidBackupsListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CidBackupsListReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CidBackupsListReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x20
	}
	if m.Offset != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CidBackupsListItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CidBackupsListItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CidBackupsListItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FileSize != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x40
	}
	if len(m.DealCid) > 0 {
		i -= len(m.DealCid)
		copy(dAtA[i:], m.DealCid)
		i = encodeVarintBox(dAtA, i, uint64(len(m.DealCid)))
		i--
		dAtA[i] = 0x3a
	}
	if m.SuccessFile != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.SuccessFile))
		i--
		dAtA[i] = 0x30
	}
	if m.FileCount != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.FileCount))
		i--
		dAtA[i] = 0x28
	}
	if m.CreatedAt != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Price) > 0 {
		i -= len(m.Price)
		copy(dAtA[i:], m.Price)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Price)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MinerId) > 0 {
		i -= len(m.MinerId)
		copy(dAtA[i:], m.MinerId)
		i = encodeVarintBox(dAtA, i, uint64(len(m.MinerId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CidBackupsListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CidBackupsListResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CidBackupsListResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBox(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Total != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BackupCountReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupCountReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupCountReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BackupCountResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackupCountResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackupCountResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Total != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintBox(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintBox(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintBox(dAtA []byte, offset int, v uint64) int {
	offset -= sovBox(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RelayReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProtocolId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.BodyBuffer)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RelayResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProtocolId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.BodyBuffer)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommonResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PingReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PingResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PeerAddressReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PeerAddressResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	if len(m.PeerAddress) > 0 {
		for _, s := range m.PeerAddress {
			l = len(s)
			n += 1 + l + sovBox(uint64(l))
		}
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *User) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBox(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Role != 0 {
		n += 1 + sovBox(uint64(m.Role))
	}
	if m.AllocatedSpace != 0 {
		n += 1 + sovBox(uint64(m.AllocatedSpace))
	}
	if m.UsedSpace != 0 {
		n += 1 + sovBox(uint64(m.UsedSpace))
	}
	if m.Status != 0 {
		n += 1 + sovBox(uint64(m.Status))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovBox(uint64(m.CreatedAt))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.SyncFil != 0 {
		n += 1 + sovBox(uint64(m.SyncFil))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiskSpace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovBox(uint64(m.Total))
	}
	if m.AdminUsed != 0 {
		n += 1 + sovBox(uint64(m.AdminUsed))
	}
	if m.OtherAllocated != 0 {
		n += 1 + sovBox(uint64(m.OtherAllocated))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceStateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceStateResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	if m.State != 0 {
		n += 1 + sovBox(uint64(m.State))
	}
	l = len(m.AdminName)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.AdminAvatar)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActivateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.RandNonce)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActivateResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.UserInfo != nil {
		l = m.UserInfo.Size()
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ForgetPassReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ForgetPassResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.UserInfo != nil {
		l = m.UserInfo.Size()
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoginReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoginResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.UserInfo != nil {
		l = m.UserInfo.Size()
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddUserReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Space != 0 {
		n += 1 + sovBox(uint64(m.Space))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserInfoResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Space != nil {
		l = m.Space.Size()
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if len(m.User) > 0 {
		for _, e := range m.User {
			l = e.Size()
			n += 1 + l + sovBox(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdatePasswordReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.OldPass)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.NewPass)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserRenameReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetUserAvatarReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovBox(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetUserAvatarResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.AvatarData)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateUserAvatarReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.AvatarData)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResetPasswordReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovBox(uint64(m.UserId))
	}
	l = len(m.NewPass)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnableUserReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovBox(uint64(m.UserId))
	}
	if m.Enable {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteUserReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovBox(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangeSpaceReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovBox(uint64(m.UserId))
	}
	if m.Space != 0 {
		n += 1 + sovBox(uint64(m.Space))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScanQrcodeReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Qrcode)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTokenByQrcodeReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Qrcode)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetTokenByQrcodeResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovBox(uint64(m.Size_))
	}
	if m.IsFolder {
		n += 2
	}
	if m.CreatedAt != 0 {
		n += 1 + sovBox(uint64(m.CreatedAt))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovBox(uint64(m.UpdatedAt))
	}
	l = len(m.Md5)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Star {
		n += 2
	}
	if m.Share {
		n += 2
	}
	if m.SubFiles != 0 {
		n += 1 + sovBox(uint64(m.SubFiles))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.ShareCount != 0 {
		n += 1 + sovBox(uint64(m.ShareCount))
	}
	l = len(m.Ext)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.ParentName)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.IsSystem != 0 {
		n += 2 + sovBox(uint64(m.IsSystem))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 2 + l + sovBox(uint64(l))
	}
	l = len(m.FormDevice)
	if l > 0 {
		n += 2 + l + sovBox(uint64(l))
	}
	if m.StartAt != 0 {
		n += 2 + sovBox(uint64(m.StartAt))
	}
	if m.EndAt != 0 {
		n += 2 + sovBox(uint64(m.EndAt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NewFolderReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.IsSystem != 0 {
		n += 1 + sovBox(uint64(m.IsSystem))
	}
	l = len(m.FormDevice)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NewFolderResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadFileReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovBox(uint64(m.Size_))
	}
	if m.BytesFrom != 0 {
		n += 1 + sovBox(uint64(m.BytesFrom))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Md5)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadFileReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.BytesFrom != 0 {
		n += 1 + sovBox(uint64(m.BytesFrom))
	}
	if m.BytesCount != 0 {
		n += 1 + sovBox(uint64(m.BytesCount))
	}
	if m.UserId != 0 {
		n += 1 + sovBox(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadFileResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovBox(uint64(m.FileSize))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.DirMask != 0 {
		n += 1 + sovBox(uint64(m.DirMask))
	}
	if m.FileType != 0 {
		n += 1 + sovBox(uint64(m.FileType))
	}
	if m.StarMask != 0 {
		n += 1 + sovBox(uint64(m.StarMask))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Order != 0 {
		n += 1 + sovBox(uint64(m.Order))
	}
	if m.Offset != 0 {
		n += 1 + sovBox(uint64(m.Offset))
	}
	if m.Limit != 0 {
		n += 1 + sovBox(uint64(m.Limit))
	}
	if m.IsEqual != 0 {
		n += 1 + sovBox(uint64(m.IsEqual))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovBox(uint64(m.Total))
	}
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovBox(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileRenameReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileDeleteReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if len(m.FileIds) > 0 {
		for _, s := range m.FileIds {
			l = len(s)
			n += 1 + l + sovBox(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileMoveReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.NewParentId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileCopyReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.NewParentId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.NewFileId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.NewFileName)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovBox(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileStarReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if len(m.FileIds) > 0 {
		for _, s := range m.FileIds {
			l = len(s)
			n += 1 + l + sovBox(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileUnstarReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if len(m.FileIds) > 0 {
		for _, s := range m.FileIds {
			l = len(s)
			n += 1 + l + sovBox(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecycleItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBox(uint64(m.Id))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovBox(uint64(m.Size_))
	}
	if m.IsFolder {
		n += 2
	}
	if m.CreatedAt != 0 {
		n += 1 + sovBox(uint64(m.CreatedAt))
	}
	l = len(m.Ext)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecycleListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Order != 0 {
		n += 1 + sovBox(uint64(m.Order))
	}
	if m.Offset != 0 {
		n += 1 + sovBox(uint64(m.Offset))
	}
	if m.Limit != 0 {
		n += 1 + sovBox(uint64(m.Limit))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.FileType != 0 {
		n += 1 + sovBox(uint64(m.FileType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecycleListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovBox(uint64(m.Total))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovBox(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecycleDeleteReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if len(m.Ids) > 0 {
		l = 0
		for _, e := range m.Ids {
			l += sovBox(uint64(e))
		}
		n += 1 + sovBox(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecycleRestoreReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if len(m.Ids) > 0 {
		l = 0
		for _, e := range m.Ids {
			l += sovBox(uint64(e))
		}
		n += 1 + sovBox(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileShareReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if len(m.FileIds) > 0 {
		for _, s := range m.FileIds {
			l = len(s)
			n += 1 + l + sovBox(uint64(l))
		}
	}
	l = len(m.UserIdList)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.StartAt != 0 {
		n += 1 + sovBox(uint64(m.StartAt))
	}
	if m.EndAt != 0 {
		n += 1 + sovBox(uint64(m.EndAt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileUnShareReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if len(m.FileIds) > 0 {
		for _, s := range m.FileIds {
			l = len(s)
			n += 1 + l + sovBox(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileCloseShareReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovBox(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShareListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovBox(uint64(m.UserId))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.DirMask != 0 {
		n += 1 + sovBox(uint64(m.DirMask))
	}
	if m.FileType != 0 {
		n += 1 + sovBox(uint64(m.FileType))
	}
	if m.StarMask != 0 {
		n += 1 + sovBox(uint64(m.StarMask))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Order != 0 {
		n += 1 + sovBox(uint64(m.Order))
	}
	if m.Offset != 0 {
		n += 1 + sovBox(uint64(m.Offset))
	}
	if m.Limit != 0 {
		n += 1 + sovBox(uint64(m.Limit))
	}
	l = len(m.Ext)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShareItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovBox(uint64(m.Size_))
	}
	if m.IsFolder {
		n += 2
	}
	l = len(m.FileType)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovBox(uint64(m.CreatedAt))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.EndAt != 0 {
		n += 1 + sovBox(uint64(m.EndAt))
	}
	if m.CountPeople != 0 {
		n += 1 + sovBox(uint64(m.CountPeople))
	}
	l = len(m.Ext)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Share {
		n += 2
	}
	l = len(m.Md5)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.SubFiles != 0 {
		n += 2 + sovBox(uint64(m.SubFiles))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 2 + l + sovBox(uint64(l))
	}
	if m.StartAt != 0 {
		n += 2 + sovBox(uint64(m.StartAt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShareListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovBox(uint64(m.Total))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovBox(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserShareListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserShareItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBox(uint64(m.Id))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovBox(uint64(m.UserId))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.FolderCount != 0 {
		n += 1 + sovBox(uint64(m.FolderCount))
	}
	if m.FileCount != 0 {
		n += 1 + sovBox(uint64(m.FileCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UserShareListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovBox(uint64(m.Total))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovBox(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileEditShareReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if len(m.FileIds) > 0 {
		for _, s := range m.FileIds {
			l = len(s)
			n += 1 + l + sovBox(uint64(l))
		}
	}
	l = len(m.UserIdList)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.StartAt != 0 {
		n += 1 + sovBox(uint64(m.StartAt))
	}
	if m.EndAt != 0 {
		n += 1 + sovBox(uint64(m.EndAt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddressbookBackupReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddressbookDeleteReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovBox(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddressbookDeleteAllReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddressbookListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovBox(uint64(m.Offset))
	}
	if m.Limit != 0 {
		n += 1 + sovBox(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Addressbook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBox(uint64(m.Id))
	}
	if m.BackupAt != 0 {
		n += 1 + sovBox(uint64(m.BackupAt))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddressbookListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovBox(uint64(m.Total))
	}
	if len(m.Addressbooks) > 0 {
		for _, e := range m.Addressbooks {
			l = e.Size()
			n += 1 + l + sovBox(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppointAddressListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovBox(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppointAddressListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovBox(uint64(m.Total))
	}
	if len(m.Addressbooks) > 0 {
		for _, e := range m.Addressbooks {
			l = e.Size()
			n += 1 + l + sovBox(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppointFileListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.IsFolder != 0 {
		n += 1 + sovBox(uint64(m.IsFolder))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppointFileListItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Ext)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovBox(uint64(m.Size_))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.IsFolder {
		n += 2
	}
	l = len(m.Paths)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Md5)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Children)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.FilePaths)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppointFileListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovBox(uint64(m.Total))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovBox(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileBackupListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.FormDevice)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovBox(uint64(m.Offset))
	}
	if m.Limit != 0 {
		n += 1 + sovBox(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileBackupListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovBox(uint64(m.Total))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovBox(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SearchFileMd5Req) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Md5)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SearchFileMd5Resp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileRecordReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Cid)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Md5)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.IsFolder != 0 {
		n += 1 + sovBox(uint64(m.IsFolder))
	}
	if m.Size_ != 0 {
		n += 1 + sovBox(uint64(m.Size_))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BackupsListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovBox(uint64(m.Offset))
	}
	if m.Limit != 0 {
		n += 1 + sovBox(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BackupsListItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBox(uint64(m.Id))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.FileCount != 0 {
		n += 1 + sovBox(uint64(m.FileCount))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovBox(uint64(m.CreatedAt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BackupsListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovBox(uint64(m.Total))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovBox(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BackupsAddReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.FileCount != 0 {
		n += 1 + sovBox(uint64(m.FileCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileLogListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovBox(uint64(m.Status))
	}
	if m.SearchTime != 0 {
		n += 1 + sovBox(uint64(m.SearchTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileLogListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovBox(uint64(m.Id))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovBox(uint64(m.Status))
	}
	l = len(m.IdList)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovBox(uint64(m.CreatedAt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SyncListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SyncListItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBox(uint64(m.Id))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.DevicePath)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovBox(uint64(m.Status))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovBox(uint64(m.CreatedAt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SyncListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovBox(uint64(m.Total))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovBox(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SyncAddReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.DevicePath)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovBox(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SyncEditReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovBox(uint64(m.Id))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.DevicePath)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovBox(uint64(m.Status))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SyncDelReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovBox(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BoxUpdateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Md5)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BoxUpdateResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	if m.Status != 0 {
		n += 1 + sovBox(uint64(m.Status))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceInfoResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Sn)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Framework)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiskCountReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiskCountResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	if m.DeviceCount != 0 {
		n += 1 + sovBox(uint64(m.DeviceCount))
	}
	if m.DeviceUsed != 0 {
		n += 1 + sovBox(uint64(m.DeviceUsed))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateWalletReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovBox(uint64(m.Type))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetWalletReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovBox(uint64(m.Type))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WalletItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovBox(uint64(m.Type))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetWalletResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovBox(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetWalletKeyReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetWalletKeyResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.AddressKey)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnableFilReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Enable {
		n += 2
	}
	l = len(m.RelayHost)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.MinerId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Price)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.SizeSum != 0 {
		n += 1 + sovBox(uint64(m.SizeSum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadFileToFilcoinReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IpfsCid)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovBox(uint64(m.FileSize))
	}
	if m.BytesFrom != 0 {
		n += 1 + sovBox(uint64(m.BytesFrom))
	}
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBackUpStatusReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IpfsCid)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetBackUpStatusResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.DealCid)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.PieceCid)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Verified {
		n += 2
	}
	if m.Duration != 0 {
		n += 1 + sovBox(uint64(m.Duration))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMinerReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PeerId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMinerResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	if len(m.Miner) > 0 {
		for _, e := range m.Miner {
			l = e.Size()
			n += 1 + l + sovBox(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Miner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MinerId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Storage)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Price)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.RelayHost)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CidBackupsListReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovBox(uint64(m.Offset))
	}
	if m.Limit != 0 {
		n += 1 + sovBox(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CidBackupsListItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBox(uint64(m.Id))
	}
	l = len(m.MinerId)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	l = len(m.Price)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovBox(uint64(m.CreatedAt))
	}
	if m.FileCount != 0 {
		n += 1 + sovBox(uint64(m.FileCount))
	}
	if m.SuccessFile != 0 {
		n += 1 + sovBox(uint64(m.SuccessFile))
	}
	l = len(m.DealCid)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovBox(uint64(m.FileSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CidBackupsListResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovBox(uint64(m.Total))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovBox(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BackupCountReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BackupCountResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovBox(uint64(m.Nonce))
	}
	if m.Code != 0 {
		n += 1 + sovBox(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBox(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovBox(uint64(m.Total))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBox(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBox(x uint64) (n int) {
	return sovBox(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RelayReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelayReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelayReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyBuffer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BodyBuffer = append(m.BodyBuffer[:0], dAtA[iNdEx:postIndex]...)
			if m.BodyBuffer == nil {
				m.BodyBuffer = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelayResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelayResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelayResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyBuffer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BodyBuffer = append(m.BodyBuffer[:0], dAtA[iNdEx:postIndex]...)
			if m.BodyBuffer == nil {
				m.BodyBuffer = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PingReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PingReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PingReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PingResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PingResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PingResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerAddressReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerAddressReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerAddressReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerAddressResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerAddressResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerAddressResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerAddress = append(m.PeerAddress, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocatedSpace", wireType)
			}
			m.AllocatedSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllocatedSpace |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedSpace", wireType)
			}
			m.UsedSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedSpace |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncFil", wireType)
			}
			m.SyncFil = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SyncFil |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiskSpace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskSpace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskSpace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminUsed", wireType)
			}
			m.AdminUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherAllocated", wireType)
			}
			m.OtherAllocated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OtherAllocated |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceStateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceStateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceStateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceStateResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceStateResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceStateResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdminName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminAvatar", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdminAvatar = append(m.AdminAvatar[:0], dAtA[iNdEx:postIndex]...)
			if m.AdminAvatar == nil {
				m.AdminAvatar = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandNonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RandNonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivateResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivateResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivateResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserInfo == nil {
				m.UserInfo = &User{}
			}
			if err := m.UserInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForgetPassReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForgetPassReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForgetPassReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForgetPassResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForgetPassResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForgetPassResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserInfo == nil {
				m.UserInfo = &User{}
			}
			if err := m.UserInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserInfo == nil {
				m.UserInfo = &User{}
			}
			if err := m.UserInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddUserReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddUserReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddUserReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Space", wireType)
			}
			m.Space = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Space |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserInfoResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserInfoResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserInfoResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Space", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Space == nil {
				m.Space = &DiskSpace{}
			}
			if err := m.Space.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = append(m.User, &User{})
			if err := m.User[len(m.User)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdatePasswordReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdatePasswordReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdatePasswordReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldPass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldPass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewPass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRenameReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRenameReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRenameReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserAvatarReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserAvatarReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserAvatarReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserAvatarResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserAvatarResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserAvatarResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvatarData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvatarData = append(m.AvatarData[:0], dAtA[iNdEx:postIndex]...)
			if m.AvatarData == nil {
				m.AvatarData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserAvatarReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserAvatarReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserAvatarReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvatarData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvatarData = append(m.AvatarData[:0], dAtA[iNdEx:postIndex]...)
			if m.AvatarData == nil {
				m.AvatarData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetPasswordReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetPasswordReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetPasswordReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewPass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnableUserReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnableUserReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnableUserReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUserReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUserReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUserReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeSpaceReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeSpaceReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeSpaceReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Space", wireType)
			}
			m.Space = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Space |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanQrcodeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanQrcodeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanQrcodeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qrcode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Qrcode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTokenByQrcodeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTokenByQrcodeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTokenByQrcodeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qrcode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Qrcode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTokenByQrcodeResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTokenByQrcodeResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTokenByQrcodeResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFolder", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFolder = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Star = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Share", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Share = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubFiles", wireType)
			}
			m.SubFiles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubFiles |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareCount", wireType)
			}
			m.ShareCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShareCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSystem", wireType)
			}
			m.IsSystem = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsSystem |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FormDevice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FormDevice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartAt", wireType)
			}
			m.StartAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndAt", wireType)
			}
			m.EndAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewFolderReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewFolderReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewFolderReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSystem", wireType)
			}
			m.IsSystem = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsSystem |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FormDevice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FormDevice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewFolderResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewFolderResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewFolderResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadFileReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadFileReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadFileReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesFrom", wireType)
			}
			m.BytesFrom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesFrom |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadFileReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadFileReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadFileReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesFrom", wireType)
			}
			m.BytesFrom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesFrom |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesCount", wireType)
			}
			m.BytesCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadFileResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadFileResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadFileResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirMask", wireType)
			}
			m.DirMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirMask |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			m.FileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarMask", wireType)
			}
			m.StarMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarMask |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEqual", wireType)
			}
			m.IsEqual = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsEqual |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, &FileItem{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileRenameReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileRenameReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileRenameReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileDeleteReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileDeleteReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileDeleteReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileIds = append(m.FileIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileMoveReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileMoveReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileMoveReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileCopyReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileCopyReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileCopyReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewFileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewFileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewFileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewFileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileStarReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileStarReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileStarReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileIds = append(m.FileIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileUnstarReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileUnstarReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileUnstarReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileIds = append(m.FileIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecycleItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecycleItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecycleItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFolder", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFolder = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecycleListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecycleListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecycleListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			m.FileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecycleListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecycleListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecycleListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &RecycleItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecycleDeleteReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecycleDeleteReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecycleDeleteReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBox
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ids = append(m.Ids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBox
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBox
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBox
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ids) == 0 {
					m.Ids = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBox
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ids = append(m.Ids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecycleRestoreReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecycleRestoreReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecycleRestoreReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBox
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ids = append(m.Ids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBox
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBox
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBox
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ids) == 0 {
					m.Ids = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBox
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ids = append(m.Ids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileShareReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileShareReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileShareReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileIds = append(m.FileIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIdList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserIdList = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartAt", wireType)
			}
			m.StartAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndAt", wireType)
			}
			m.EndAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileUnShareReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileUnShareReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileUnShareReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileIds = append(m.FileIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileCloseShareReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileCloseShareReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileCloseShareReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShareListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShareListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShareListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirMask", wireType)
			}
			m.DirMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DirMask |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			m.FileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarMask", wireType)
			}
			m.StarMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StarMask |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShareItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShareItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShareItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFolder", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFolder = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndAt", wireType)
			}
			m.EndAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountPeople", wireType)
			}
			m.CountPeople = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountPeople |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Share", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Share = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubFiles", wireType)
			}
			m.SubFiles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubFiles |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartAt", wireType)
			}
			m.StartAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShareListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShareListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShareListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ShareItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserShareListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserShareListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserShareListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserShareItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserShareItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserShareItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FolderCount", wireType)
			}
			m.FolderCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FolderCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileCount", wireType)
			}
			m.FileCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserShareListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserShareListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserShareListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &UserShareItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileEditShareReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileEditShareReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileEditShareReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileIds = append(m.FileIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIdList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserIdList = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartAt", wireType)
			}
			m.StartAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndAt", wireType)
			}
			m.EndAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressbookBackupReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressbookBackupReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressbookBackupReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressbookDeleteReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressbookDeleteReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressbookDeleteReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressbookDeleteAllReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressbookDeleteAllReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressbookDeleteAllReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressbookListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressbookListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressbookListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Addressbook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Addressbook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Addressbook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupAt", wireType)
			}
			m.BackupAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackupAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressbookListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressbookListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressbookListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addressbooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addressbooks = append(m.Addressbooks, &Addressbook{})
			if err := m.Addressbooks[len(m.Addressbooks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppointAddressListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppointAddressListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppointAddressListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppointAddressListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppointAddressListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppointAddressListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addressbooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addressbooks = append(m.Addressbooks, &Addressbook{})
			if err := m.Addressbooks[len(m.Addressbooks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppointFileListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppointFileListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppointFileListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFolder", wireType)
			}
			m.IsFolder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsFolder |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppointFileListItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppointFileListItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppointFileListItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFolder", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFolder = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paths", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paths = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePaths", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePaths = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppointFileListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppointFileListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppointFileListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &AppointFileListItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileBackupListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileBackupListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileBackupListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FormDevice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FormDevice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileBackupListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileBackupListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileBackupListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &AppointFileListItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchFileMd5Req) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchFileMd5Req: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchFileMd5Req: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchFileMd5Resp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchFileMd5Resp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchFileMd5Resp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileRecordReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileRecordReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileRecordReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFolder", wireType)
			}
			m.IsFolder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsFolder |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupsListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupsListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupsListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupsListItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupsListItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupsListItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileCount", wireType)
			}
			m.FileCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupsListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupsListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupsListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &BackupsListItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupsAddReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupsAddReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupsAddReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileCount", wireType)
			}
			m.FileCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileLogListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileLogListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileLogListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchTime", wireType)
			}
			m.SearchTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SearchTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileLogListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileLogListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileLogListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdList = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncListItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncListItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncListItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevicePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevicePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &SyncListItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncAddReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncAddReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncAddReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevicePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevicePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncEditReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncEditReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncEditReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevicePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DevicePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncDelReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncDelReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncDelReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BoxUpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoxUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoxUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BoxUpdateResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoxUpdateResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoxUpdateResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceInfoResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceInfoResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceInfoResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Framework", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Framework = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiskCountReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskCountReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskCountReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiskCountResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiskCountResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiskCountResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceCount", wireType)
			}
			m.DeviceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceUsed", wireType)
			}
			m.DeviceUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateWalletReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateWalletReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateWalletReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWalletReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWalletReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWalletReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WalletItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WalletItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WalletItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWalletResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWalletResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWalletResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &WalletItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWalletKeyReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWalletKeyReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWalletKeyReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetWalletKeyResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetWalletKeyResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetWalletKeyResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnableFilReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnableFilReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnableFilReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayHost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayHost = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Price = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeSum", wireType)
			}
			m.SizeSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeSum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadFileToFilcoinReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadFileToFilcoinReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadFileToFilcoinReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpfsCid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpfsCid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesFrom", wireType)
			}
			m.BytesFrom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesFrom |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBackUpStatusReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBackUpStatusReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBackUpStatusReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpfsCid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpfsCid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetBackUpStatusResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetBackUpStatusResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetBackUpStatusResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DealCid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DealCid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PieceCid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PieceCid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verified = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMinerReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMinerReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMinerReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMinerResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMinerResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMinerResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Miner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Miner = append(m.Miner, &Miner{})
			if err := m.Miner[len(m.Miner)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Miner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Miner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Miner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Storage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Price = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayHost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayHost = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CidBackupsListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CidBackupsListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CidBackupsListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CidBackupsListItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CidBackupsListItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CidBackupsListItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Price = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileCount", wireType)
			}
			m.FileCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessFile", wireType)
			}
			m.SuccessFile = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuccessFile |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DealCid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DealCid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CidBackupsListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CidBackupsListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CidBackupsListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &CidBackupsListItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupCountReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupCountReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupCountReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackupCountResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBox
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupCountResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupCountResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= Code(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBox
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBox
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBox
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBox(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBox
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBox(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBox
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBox
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBox
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBox
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBox
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBox
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBox        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBox          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBox = fmt.Errorf("proto: unexpected end of group")
)
